import pandas as pd123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport numpy as np123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport time123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# read the file with scores and the file with labels into panda frames123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFpd_solutions = pd.read_csv('solution.csv')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFpd_multiframe_submission = pd.read_csv('submission.csv')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# extract meaningful information from panda frames into numpy arrays123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# every ligand has multiple frames in "predictions"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# predictions_by_ligand reduces multiple positions of the same ligand into one single prediction123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFpredictions_by_ligand_names = np.array(list(pd_multiframe_submission[pd_multiframe_submission.columns[0]]))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFmultiframe_predictions = np.array(pd_multiframe_submission[pd_multiframe_submission.columns[1:]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFpredictions_by_ligand = np.mean(multiframe_predictions[:,0:6],axis=1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#predictions_by_ligand = np.mean(multiframe_predictions,axis=1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFsolutions_by_ligand_names = np.array(pd_solutions.ix[:,0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFsolutions_by_ligand = np.array(pd_solutions.ix[:,1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# get the list of receptors (receptor is a base of the ligand's name ie nsbb for nsbp_10101)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef receptor_name_from_ligand_name(ligand_name):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return ligand_name.split("_")[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFall_receptors = sorted(set(map(receptor_name_from_ligand_name,predictions_by_ligand_names)))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# for each receptor append all of it's ligands and predictions into two lists123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFnumber_of_receptors = len(all_receptors)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFpredictions_by_receptor_names = [[] for _ in xrange(number_of_receptors)]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFpredictions_by_receptor = [[] for _ in xrange(number_of_receptors)]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef append_to_predictions(ligand_name,prediction,predictions_by_ligand_names=predictions_by_ligand_names,predictions_by_ligand=predictions_by_ligand):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    receptor_name = ligand_name.split("_")[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    receptor_idx = all_receptors.index(receptor_name)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    predictions_by_receptor_names[receptor_idx].append(ligand_name)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    predictions_by_receptor[receptor_idx].append(prediction)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return None123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFmap(append_to_predictions,predictions_by_ligand_names,predictions_by_ligand)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# for each receptor sort it's ligands by predictions123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfor receptor_idx in range(number_of_receptors):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    order = np.flipud(np.asarray(predictions_by_receptor[receptor_idx]).argsort())123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    predictions_by_receptor[receptor_idx] = list(np.asarray(predictions_by_receptor[receptor_idx])[order])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    predictions_by_receptor_names[receptor_idx] = list(np.asarray(predictions_by_receptor_names[receptor_idx])[order])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print predictions_by_receptor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# map each of the ligands to it's label123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFlist_solutions_by_ligand_names = list(solutions_by_ligand_names)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFlabels_by_receptor = [[] for _ in xrange(number_of_receptors)]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef ligand_name_to_label_index(ligand_name,solutions_by_ligand_names=solutions_by_ligand_names,solutions_by_ligand=solutions_by_ligand):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    label_index = list_solutions_by_ligand_names.index(ligand_name)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return label_index123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfor receptor_idx in range(number_of_receptors):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    label_indexes_for_receptor = np.squeeze(map(ligand_name_to_label_index,predictions_by_receptor_names[receptor_idx]))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    labels_for_receptor = list(solutions_by_ligand[label_indexes_for_receptor])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    labels_by_receptor[receptor_idx].append(labels_for_receptor)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# calculate AUC for each of the receptors"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef auc_from_labels(labels):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """calculates area under the curve AUC for binary predictions/labels needs123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    sorted in descending order predictions"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # calculate the number of positive labels123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    num_positives = np.sum(np.asarray(labels, dtype=bool) == True)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    num_predictions = len(labels)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #print "predictions:",labels123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print "num predictions:",num_predictions123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # return NAN when no positives are present123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if num_positives == 0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return float('nan')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # slide from top to the bottom;123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # each time slide the threshold so as to predict one more label as positive123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    roc_curve = np.array([0.0, 0.0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    TP_above_threshold = 0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for idx in range(num_predictions):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if labels[idx] == True:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            TP_above_threshold += 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # calculate True Positives Rate123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # TPR = TP / num_real_positives123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        TPR = TP_above_threshold / float(num_positives)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # FPR = FP / num_real_negatives123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        FPR = (idx + 1 - TP_above_threshold) / (num_predictions - float(num_positives))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        roc_curve = np.vstack((roc_curve, [FPR, TPR]))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    roc_curve = np.vstack((roc_curve, [1.0, 1.0]))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # reduce into TP and FP rate, integrate with trapezoid to calculate AUC123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    auc = np.trapz(roc_curve[:, 1], x=roc_curve[:, 0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return auc123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFaucs = np.array([])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFi = 0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfor labels_for_receptor in labels_by_receptor:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    auc = auc_from_labels(np.squeeze(labels_for_receptor))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    aucs = np.append(aucs,auc)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print "receptor:",all_receptors[i]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print auc123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    i+=1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFprint "average:",np.average(aucs)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef auc(self, predictions, labels):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """calculates area under the curve AUC for binary predictions/labels needs123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    sorted in descending order predictions"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # sort the array by predictions in descending order in case it has not been done123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    order = np.flipud(predictions.argsort())123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    labels = labels[order]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # clean labels, calculate the number of positive labels123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    labeled_true = (np.asarray(labels, dtype=bool) == True)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    num_positives = np.sum(labeled_true)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    num_predictions = len(labeled_true)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # If no positive result return nan123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if num_positives == 0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return float('nan')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # slide from top to the bottom;123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # each time slide the threshold so as to predict one more label as positive123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    roc_curve = np.array([0.0, 0.0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    TP_above_threshold = 0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for predict_as_positive in range(num_predictions):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if labeled_true[predict_as_positive] == True:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            TP_above_threshold += 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # calculate True Positives Rate123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # TPR = TP / num_real_positives123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        TPR = TP_above_threshold / float(num_positives)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # FPR = FP / num_real_negatives123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        FPR = (predict_as_positive + 1 - TP_above_threshold) / (num_predictions - float(num_positives))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        roc_curve = np.vstack((roc_curve, [FPR, TPR]))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    roc_curve = np.vstack((roc_curve, [1.0, 1.0]))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # reduce into TP and FP rate, integrate with trapezoid to calculate AUC123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    auc = np.trapz(roc_curve[:, 1], x=roc_curve[:, 0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return auc123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF