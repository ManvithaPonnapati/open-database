from __future__ import absolute_import123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfrom __future__ import division123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport threading123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport weakref123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfrom tensorflow.core.protobuf import queue_runner_pb2123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfrom tensorflow.python.framework import errors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfrom tensorflow.python.framework import ops123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfrom tensorflow.python.platform import tf_logging as logging123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport tensorflow as tf123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport numpy as np123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport time123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# generate one very large tensor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# take slices from that tensor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# assuming our tensor is big,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# random slices from it should represent affine transform123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef generate_deep_affine_transform(num_frames):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Generates a very big batch of affine transform matrices in 3D. The first dimension is batch, the other two123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    describe typical affine transform matrices. Deep affine transform can be generated once in the beginning123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    of training, and later slices can be taken from it randomly to speed up the computation."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # shift range is hard coded to 10A because that's how the proteins look like123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # rotation range is hardcoded to 360 degrees123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    shift_range = tf.constant(10, dtype=tf.float32)  # FIXME123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rotation_range = tf.cast(tf.convert_to_tensor(0), dtype=tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # randomly shift along X,Y,Z123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    x_shift = tf.random_uniform([num_frames], minval=-1, maxval=1, dtype=tf.float32) * shift_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    y_shift = tf.random_uniform([num_frames], minval=-1, maxval=1, dtype=tf.float32) * shift_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    z_shift = tf.random_uniform([num_frames], minval=-1, maxval=1, dtype=tf.float32) * shift_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [1, 0, 0, random_x_shift],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, 1, 0, random_y_shift],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, 0, 1, random_z_shift],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, 0, 0, 1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # try to do the following:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # generate nine tensors for each of them123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # concatenate and reshape sixteen tensors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_0 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_3 = x_shift123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_1 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_3 = y_shift123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_2 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_3 = z_shift123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_3 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    xyz_shift_stick = tf.stack(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [afn0_0, afn0_1, afn0_2, afn0_3, afn1_0, afn1_1, afn1_2, afn1_3, afn2_0, afn2_1, afn2_2, afn2_3, afn3_0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         afn3_1, afn3_2, afn3_3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    xyz_shift_matrix = tf.transpose(tf.reshape(xyz_shift_stick, [4, 4, num_frames]), perm=[2, 0, 1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # randomly rotate along X123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    x_rot = tf.random_uniform([num_frames], minval=-1, maxval=1, dtype=tf.float32, seed=None,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                              name=None) * rotation_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [[1, 0, 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, cos(x_rot),-sin(x_rot),0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, sin(x_rot),cos(x_rot),0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, 0, 0, 1]],dtype=tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_0 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_1 = tf.cos(x_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_2 = -tf.sin(x_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_1 = tf.sin(x_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_2 = tf.cos(x_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_3 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    x_rot_stick = tf.stack(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [afn0_0, afn0_1, afn0_2, afn0_3, afn1_0, afn1_1, afn1_2, afn1_3, afn2_0, afn2_1, afn2_2, afn2_3, afn3_0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         afn3_1, afn3_2, afn3_3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    x_rot_matrix = tf.transpose(tf.reshape(x_rot_stick, [4, 4, num_frames]), perm=[2, 0, 1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # randomly rotate along Y123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    y_rot = tf.random_uniform([num_frames], minval=-1, maxval=1, dtype=tf.float32, seed=None,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                              name=None) * rotation_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [cos(y_rot), 0,sin(y_rot), 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, 1, 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [-sin(y_rot), 0,cos(y_rot), 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, 0 ,0 ,1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_0 = tf.cos(y_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_2 = tf.sin(y_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_1 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_0 = -tf.sin(y_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_2 = tf.cos(y_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_3 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    y_rot_stick = tf.stack(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [afn0_0, afn0_1, afn0_2, afn0_3, afn1_0, afn1_1, afn1_2, afn1_3, afn2_0, afn2_1, afn2_2, afn2_3, afn3_0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         afn3_1, afn3_2, afn3_3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    y_rot_matrix = tf.transpose(tf.reshape(y_rot_stick, [4, 4, num_frames]), perm=[2, 0, 1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # randomly rotate along Z123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    z_rot = tf.random_uniform([num_frames], minval=-1, maxval=1, dtype=tf.float32, seed=None,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                              name=None) * rotation_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [[cos(z_rot), -sin(z_rot), 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [sin(z_rot), cos(z_rot), 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, 0, 1, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, 0, 0, 1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_0 = tf.cos(z_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_1 = -tf.sin(z_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_0 = tf.sin(z_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_1 = tf.cos(z_rot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_2 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_3 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    z_rot_stick = tf.stack(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [afn0_0, afn0_1, afn0_2, afn0_3, afn1_0, afn1_1, afn1_2, afn1_3, afn2_0, afn2_1, afn2_2, afn2_3, afn3_0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         afn3_1, afn3_2, afn3_3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    z_rot_matrix = tf.transpose(tf.reshape(z_rot_stick, [4, 4, num_frames]), perm=[2, 0, 1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    xyz_shift_xyz_rot = tf.matmul(tf.matmul(tf.matmul(xyz_shift_matrix, x_rot_matrix), y_rot_matrix), z_rot_matrix)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return xyz_shift_xyz_rot123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef affine_transform(coordinates,transition_matrix):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #<<<<<<< HEAD123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Applies affine transform to the array of XYZ coordinates. By default generates a random affine transform matrix.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    coordinates_with_ones = tf.concat([coordinates, tf.cast(tf.ones([tf.shape(coordinates)[0],1]),tf.float32)],1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    transformed_coords = tf.matmul(coordinates_with_ones,tf.transpose(transition_matrix))[0:,:-1]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return transformed_coords,transition_matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef deep_affine_transform(coords,deep_transition_matrix):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Applies multiple affine transformations to the array of X,Y,Z coordinates."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # TODO generate random affine transform matrix by default123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    depth_dimensions = tf.shape(deep_transition_matrix)[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    coords_with_ones = tf.concat([coords, tf.cast(tf.ones([tf.shape(coords)[0],1]),tf.float32)],1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    broadcast_coords_with_ones = tf.reshape(tf.tile(coords_with_ones,[depth_dimensions,1]),[depth_dimensions,tf.shape(coords)[0],4])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    transformed_coords = tf.batch_matmul(broadcast_coords_with_ones,tf.transpose(deep_transition_matrix,[0,2,1]))[:,:,:3]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return transformed_coords,deep_transition_matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef exhaustive_affine_transform(shift_ranges=[10,10,10],shift_deltas=[1,1,1],rot_ranges=[360,360,360]):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """By default,makes shifts by 1, in X,Y,Z directions"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # shift along X,Y,Z123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    x_shift = tf.range(start=-shift_ranges[0],limit=shift_ranges[0],delta=shift_deltas[0],dtype=tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    y_shift = tf.range(start=-shift_ranges[1],limit=shift_ranges[1],delta=shift_deltas[1],dtype=tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    z_shift = tf.range(start=-shift_ranges[2],limit=shift_ranges[2],delta=shift_deltas[2],dtype=tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [1, 0, 0, random_x_shift],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, 1, 0, random_y_shift],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, 0, 1, random_z_shift],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # [0, 0, 0, 1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # get affine transformation shifts along X123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    num_frames = tf.shape(x_shift)[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_0 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_3 = x_shift123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_1 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_2 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_3 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    x_shift_stick = tf.stack(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [afn0_0, afn0_1, afn0_2, afn0_3, afn1_0, afn1_1, afn1_2, afn1_3, afn2_0, afn2_1, afn2_2, afn2_3, afn3_0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         afn3_1, afn3_2, afn3_3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    x_shift_matrix = tf.transpose(tf.reshape(x_shift_stick, [4, 4, num_frames]), perm=[2, 0, 1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # get affine transformations along Y123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_0 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_1 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_3 = y_shift123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_2 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_3 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    y_shift_stick = tf.stack(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [afn0_0, afn0_1, afn0_2, afn0_3, afn1_0, afn1_1, afn1_2, afn1_3, afn2_0, afn2_1, afn2_2, afn2_3, afn3_0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         afn3_1, afn3_2, afn3_3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    y_shift_matrix = tf.transpose(tf.reshape(y_shift_stick, [4, 4, num_frames]), perm=[2, 0, 1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # get affine transformations along Z123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_0 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_1 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_2 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_3 = z_shift123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_3 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    z_shift_stick = tf.stack(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [afn0_0, afn0_1, afn0_2, afn0_3, afn1_0, afn1_1, afn1_2, afn1_3, afn2_0, afn2_1, afn2_2, afn2_3, afn3_0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         afn3_1, afn3_2, afn3_3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    z_shift_matrix = tf.transpose(tf.reshape(z_shift_stick, [4, 4, num_frames]), perm=[2, 0, 1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # combine X,Y,Z shifts together123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    broadcast_x = tf.tile(x_shift_matrix, [tf.shape(y_shift_matrix)[0], 1, 1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    broadcast_y = tf.reshape(tf.tile(y_shift_matrix, [1, tf.shape(x_shift_matrix)[0], 1]),shape=[tf.shape(x_shift_matrix)[0] * tf.shape(y_shift_matrix)[0], 4, 4])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    xy_shift_matrix = tf.matmul(broadcast_x,broadcast_y)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    broadcast_xy = tf.tile(xy_shift_matrix, [tf.shape(z_shift_matrix)[0], 1, 1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    broadcast_z = tf.reshape(tf.tile(z_shift_matrix, [1, tf.shape(xy_shift_matrix)[0], 1]),shape=[tf.shape(xy_shift_matrix)[0] * tf.shape(z_shift_matrix)[0], 4, 4])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    xyz_shift_matrix = tf.matmul(broadcast_xy, broadcast_z)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return xyz_shift_matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef identity_matrices(num_frames):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    "for convenience of generating identity transformation matrices"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_0 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn0_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_1 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn1_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_2 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn2_3 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_0 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_1 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_2 = tf.zeros([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    afn3_3 = tf.ones([num_frames])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    identity_stick = tf.stack(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [afn0_0, afn0_1, afn0_2, afn0_3, afn1_0, afn1_1, afn1_2, afn1_3, afn2_0, afn2_1, afn2_2, afn2_3, afn3_0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         afn3_1, afn3_2, afn3_3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return tf.transpose(tf.reshape(identity_stick, [4, 4, num_frames]), perm=[2, 0, 1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef var_stats(vals):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    "Take a dictionary of variables and variable names, and prints statistics."123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    message = ""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    message += "================================================================================\n"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for val in vals:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        message+= ("val:"+str(val))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        message+=(str((vals[val]))+"\n")123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for val in vals:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        message+=str(val)+"\tlen:"+str(len(vals[val]))+ str("min:" + "%.3f" % min(vals[val])) \123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                 + str("max:" + "%.3f" % max(vals[val])) + str("ave:" + "%.3f" % np.average(vals[val])) \123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                 + str("median:" + "%.3f" % np.sort(vals[val], axis=0)[len(vals[val])//2]) \123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                 + str("first:" + "%.3f" % vals[val][0]) + str("last:" + "%.3f" % vals[val][-1]) \123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                 + str("middle (no formatting):" + str(vals[val][len(vals[val])//2]) + "\n")123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    message+="================================================================================\n"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return message123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFclass QueueRunner(object):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  I borrowed this from a standard TensorFlow collection123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  The only difference between tf.QueueRunner and this one is that it does not close the queue after terminating123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  all threads. So I can initiate and kill threads on the same queue many times.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  Holds a list of enqueue operations for a queue, each to be run in a thread.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  Queues are a convenient TensorFlow mechanism to compute tensors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  asynchronously using multiple threads. For example in the canonical 'Input123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  Reader' setup one set of threads generates filenames in a queue; a second set123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  of threads read records from the files, processes them, and enqueues tensors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  on a second queue; a third set of threads dequeues these input records to123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  construct batches and runs them through training operations.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  There are several delicate issues when running multiple threads that way:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  closing the queues in sequence as the input is exhausted, correctly catching123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  and reporting exceptions, etc.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  The `QueueRunner`, combined with the `Coordinator`, helps handle these issues.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def __init__(self, queue=None, enqueue_ops=None, close_op=None,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF               cancel_op=None, queue_closed_exception_types=None,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF               queue_runner_def=None, import_scope=None):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Create a QueueRunner.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    On construction the `QueueRunner` adds an op to close the queue.  That op123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    will be run if the enqueue ops raise exceptions.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    When you later call the `create_threads()` method, the `QueueRunner` will123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    create one thread for each op in `enqueue_ops`.  Each thread will run its123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    enqueue op in parallel with the other threads.  The enqueue ops do not have123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    to all be the same op, but it is expected that they all enqueue tensors in123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    `queue`.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Args:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      queue: A `Queue`.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      enqueue_ops: List of enqueue ops to run in threads later.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      close_op: Op to close the queue. Pending enqueue ops are preserved.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      cancel_op: Op to close the queue and cancel pending enqueue ops.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      queue_closed_exception_types: Optional tuple of Exception types that123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        indicate that the queue has been closed when raised during an enqueue123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        operation.  Defaults to `(tf.errors.OutOfRangeError,)`.  Another common123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        case includes `(tf.errors.OutOfRangeError, tf.errors.CancelledError)`,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        when some of the enqueue ops may dequeue from other Queues.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      queue_runner_def: Optional `QueueRunnerDef` protocol buffer. If specified,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        recreates the QueueRunner from its contents. `queue_runner_def` and the123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        other arguments are mutually exclusive.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      import_scope: Optional `string`. Name scope to add. Only used when123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        initializing from protocol buffer.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Raises:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      ValueError: If both `queue_runner_def` and `queue` are both specified.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      ValueError: If `queue` or `enqueue_ops` are not provided when not123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        restoring from `queue_runner_def`.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if queue_runner_def:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      if queue or enqueue_ops:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        raise ValueError("queue_runner_def and queue are mutually exclusive.")123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      self._init_from_proto(queue_runner_def,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                            import_scope=import_scope)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      self._init_from_args(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          queue=queue, enqueue_ops=enqueue_ops,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          close_op=close_op, cancel_op=cancel_op,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          queue_closed_exception_types=queue_closed_exception_types)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Protect the count of runs to wait for.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._lock = threading.Lock()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # A map from a session object to the number of outstanding queue runner123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # threads for that session.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._runs_per_session = weakref.WeakKeyDictionary()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # List of exceptions raised by the running threads.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._exceptions_raised = []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def _init_from_args(self, queue=None, enqueue_ops=None, close_op=None,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                      cancel_op=None, queue_closed_exception_types=None):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Create a QueueRunner from arguments.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Args:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      queue: A `Queue`.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      enqueue_ops: List of enqueue ops to run in threads later.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      close_op: Op to close the queue. Pending enqueue ops are preserved.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      cancel_op: Op to close the queue and cancel pending enqueue ops.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      queue_closed_exception_types: Tuple of exception types, which indicate123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        the queue has been safely closed.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Raises:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      ValueError: If `queue` or `enqueue_ops` are not provided when not123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        restoring from `queue_runner_def`.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      TypeError: If `queue_closed_exception_types` is provided, but is not123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        a non-empty tuple of error types (subclasses of `tf.errors.OpError`).123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if not queue or not enqueue_ops:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      raise ValueError("Must provide queue and enqueue_ops.")123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._queue = queue123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._enqueue_ops = enqueue_ops123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._close_op = close_op123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._cancel_op = cancel_op123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if queue_closed_exception_types is not None:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      if (not isinstance(queue_closed_exception_types, tuple)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          or not queue_closed_exception_types123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          or not all(issubclass(t, errors.OpError)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                     for t in queue_closed_exception_types)):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        raise TypeError(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            "queue_closed_exception_types, when provided, "123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            "must be a non-empty list of tf.error types, but saw: %s"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            % queue_closed_exception_types)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._queue_closed_exception_types = queue_closed_exception_types123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Close when no more will be produced, but pending enqueues should be123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # preserved.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if self._close_op is None:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      self._close_op = self._queue.close()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Close and cancel pending enqueues since there was an error and we want123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # to unblock everything so we can cleanly exit.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if self._cancel_op is None:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      self._cancel_op = self._queue.close(cancel_pending_enqueues=True)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if not self._queue_closed_exception_types:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      self._queue_closed_exception_types = (errors.OutOfRangeError,)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      self._queue_closed_exception_types = tuple(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          self._queue_closed_exception_types)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def _init_from_proto(self, queue_runner_def, import_scope=None):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Create a QueueRunner from `QueueRunnerDef`.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Args:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      queue_runner_def: Optional `QueueRunnerDef` protocol buffer.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      import_scope: Optional `string`. Name scope to add.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    assert isinstance(queue_runner_def, queue_runner_pb2.QueueRunnerDef)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    g = ops.get_default_graph()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._queue = g.as_graph_element(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        ops.prepend_name_scope(queue_runner_def.queue_name, import_scope))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._enqueue_ops = [g.as_graph_element(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        ops.prepend_name_scope(op, import_scope))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                         for op in queue_runner_def.enqueue_op_name]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._close_op = g.as_graph_element(ops.prepend_name_scope(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        queue_runner_def.close_op_name, import_scope))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._cancel_op = g.as_graph_element(ops.prepend_name_scope(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        queue_runner_def.cancel_op_name, import_scope))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    self._queue_closed_exception_types = tuple(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        errors.exception_type_from_error_code(code)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        for code in queue_runner_def.queue_closed_exception_types)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Legacy support for old QueueRunnerDefs created before this field123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # was added.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if not self._queue_closed_exception_types:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      self._queue_closed_exception_types = (errors.OutOfRangeError,)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  @property123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def queue(self):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return self._queue123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  @property123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def enqueue_ops(self):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return self._enqueue_ops123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  @property123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def close_op(self):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return self._close_op123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  @property123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def cancel_op(self):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return self._cancel_op123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  @property123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def queue_closed_exception_types(self):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return self._queue_closed_exception_types123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  @property123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def exceptions_raised(self):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Exceptions raised but not handled by the `QueueRunner` threads.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Exceptions raised in queue runner threads are handled in one of two ways123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    depending on whether or not a `Coordinator` was passed to123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    `create_threads()`:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    * With a `Coordinator`, exceptions are reported to the coordinator and123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      forgotten by the `QueueRunner`.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    * Without a `Coordinator`, exceptions are captured by the `QueueRunner` and123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      made available in this `exceptions_raised` property.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Returns:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      A list of Python `Exception` objects.  The list is empty if no exception123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      was captured.  (No exceptions are captured when using a Coordinator.)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return self._exceptions_raised123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  @property123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def name(self):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """The string name of the underlying Queue."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return self._queue.name123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  # pylint: disable=broad-except123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def _run(self, sess, enqueue_op, coord=None):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Execute the enqueue op in a loop, close the queue in case of error.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Args:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      sess: A Session.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      enqueue_op: The Operation to run.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      coord: Optional Coordinator object for reporting errors and checking123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        for stop conditions.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    decremented = False123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    try:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      while True:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if coord and coord.should_stop():123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          break123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        try:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          sess.run(enqueue_op)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        except self._queue_closed_exception_types:  # pylint: disable=catching-non-exception123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          # This exception indicates that a queue was closed.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          with self._lock:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            self._runs_per_session[sess] -= 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            decremented = True123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            if self._runs_per_session[sess] == 0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF              try:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                sess.run(self._close_op)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF              except Exception as e:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                # Intentionally ignore errors from close_op.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                logging.vlog(1, "Ignored exception: %s", str(e))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            return123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    except Exception as e:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      # This catches all other exceptions.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      if coord:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        coord.request_stop(e)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        logging.error("Exception in QueueRunner: %s", str(e))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        with self._lock:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          self._exceptions_raised.append(e)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        raise123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    finally:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      # Make sure we account for all terminations: normal or errors.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      if not decremented:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        with self._lock:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          self._runs_per_session[sess] -= 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def _close_on_stop(self, sess, cancel_op, coord):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Close the queue when the Coordinator requests stop.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Args:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      sess: A Session.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      cancel_op: The Operation to run.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      coord: Coordinator.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    coord.wait_for_stop()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    try:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # TODO(maksym): the next two lines are the only difference from TF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # sess.run(cancel_op)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        pass123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    except Exception as e:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      # Intentionally ignore errors from cancel_op.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      logging.vlog(1, "Ignored exception: %s", str(e))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  # pylint: enable=broad-except123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def create_threads(self, sess, logger, coord=None, daemon=False, start=False):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Create threads to run the enqueue ops for the given session.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    This method requires a session in which the graph was launched.  It creates123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    a list of threads, optionally starting them.  There is one thread for each123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    op passed in `enqueue_ops`.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    The `coord` argument is an optional coordinator that the threads will use123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    to terminate together and report exceptions.  If a coordinator is given,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    this method starts an additional thread to close the queue when the123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    coordinator requests a stop.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    If previously created threads for the given session are still running, no123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    new threads will be created.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Args:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      sess: A `Session`.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      coord: Optional `Coordinator` object for reporting errors and checking123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        stop conditions.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      daemon: Boolean.  If `True` make the threads daemon threads.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      start: Boolean.  If `True` starts the threads.  If `False` the123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        caller must call the `start()` method of the returned threads.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Returns:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      A list of threads.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    with self._lock:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      try:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if self._runs_per_session[sess] > 0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          # Already started: no new threads to return.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          return []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      except KeyError:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # We haven't seen this session yet.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        pass123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      self._runs_per_session[sess] = len(self._enqueue_ops)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      self._exceptions_raised = []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ret_threads = [threading.Thread(target=self._run, args=(sess, op, coord))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                   for op in self._enqueue_ops]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if coord:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      ret_threads.append(threading.Thread(target=self._close_on_stop,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                          args=(sess, self._cancel_op, coord)))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    started_threads = 0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for t in ret_threads:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      if coord:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        coord.register_thread(t)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      if daemon:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        t.daemon = True123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      if start:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        log_message = ""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        t.start()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        log_message += str("[tr:" + str(started_threads) + "]")123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        logger.debug(log_message)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        started_threads+=1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    time.sleep(0.25)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    print "[all threads started. queue.size:",sess.run(self.queue.size()),"]"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return ret_threads123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def to_proto(self, export_scope=None):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Converts this `QueueRunner` to a `QueueRunnerDef` protocol buffer.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Args:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      export_scope: Optional `string`. Name scope to remove.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Returns:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      A `QueueRunnerDef` protocol buffer, or `None` if the `Variable` is not in123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      the specified name scope.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if (export_scope is None or123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        self.queue.name.startswith(export_scope)):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      queue_runner_def = queue_runner_pb2.QueueRunnerDef()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      queue_runner_def.queue_name = ops.strip_name_scope(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          self.queue.name, export_scope)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      for enqueue_op in self.enqueue_ops:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        queue_runner_def.enqueue_op_name.append(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            ops.strip_name_scope(enqueue_op.name, export_scope))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      queue_runner_def.close_op_name = ops.strip_name_scope(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          self.close_op.name, export_scope)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      queue_runner_def.cancel_op_name = ops.strip_name_scope(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          self.cancel_op.name, export_scope)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      queue_runner_def.queue_closed_exception_types.extend([123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          errors.error_code_from_exception_type(cls)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF          for cls in self._queue_closed_exception_types])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      return queue_runner_def123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF      return None123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  @staticmethod123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF  def from_proto(queue_runner_def, import_scope=None):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Returns a `QueueRunner` object created from `queue_runner_def`."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return QueueRunner(queue_runner_def=queue_runner_def,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                       import_scope=import_scope)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef dequeue_all(sess, dequeue_op, logger, op_name=None):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    logger.debug(str(op_name) + ":starting to deque all examples")123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    try:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        while True:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            sess.run(dequeue_op, options=tf.RunOptions(timeout_in_ms=500))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            logger.debug(".")123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    except tf.errors.DeadlineExceededError:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        logger.debug(str(op_name) + ":queue empty")123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef decode_av4(file_path):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # read the whole file123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    serialized_record = tf.read_file(file_path)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # decode everything into int32123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    tmp_decoded_record = tf.decode_raw(serialized_record, tf.int32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # first four bytes describe the number of frames in a record123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    number_of_frames = tf.slice(tmp_decoded_record, [0], [1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # labels are saved as int32 * number of frames in the record123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    labels = tf.slice(tmp_decoded_record, [1], number_of_frames)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # elements are saved as int32 and their number is == to the number of atoms123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    number_of_atoms = tf.to_int32((tf.shape(tmp_decoded_record) - number_of_frames - 1) / (3 * number_of_frames + 1))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    elements = tf.slice(tmp_decoded_record, number_of_frames + 1, number_of_atoms)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # coordinates are saved as a stack of X,Y,Z where the first(vertical) dimension123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # corresponds to the number of atoms123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # second (horizontal dimension) is x,y,z coordinate of every atom and is always 3123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # third (depth) dimension corresponds to the number of frames123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    coords_shape = tf.concat([number_of_atoms, [3], number_of_frames], 0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    tmp_coords = tf.slice(tmp_decoded_record, number_of_frames + number_of_atoms + 1,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                          tf.shape(tmp_decoded_record) - number_of_frames - number_of_atoms - 1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    multiframe_coords = tf.bitcast(tf.reshape(tmp_coords, coords_shape), type=tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return labels, elements, multiframe_coords123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF