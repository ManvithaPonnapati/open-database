import tensorflow as tf123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport numpy as np123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef cross_entropy_with_RMSD(logits, lig_RMSDs, RMSD_threshold=3.0):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """ Arbitrary function with assumptions:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    RMSD == 0 is a correct position     ; label = 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    RMSD > 0 is an incorrect position   ; label = 0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    For positions RMSD > RMSD threshold; or RMSD == 0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    the cost is a regular cross entropy cost123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    For positions:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    0 < RMSD < RMSD_threshold123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    final cost is multiplied by (RMSD_threshold - RMSD_ligand)/RMSD_threshold123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    labels = tf.cast((lig_RMSDs < 0.01), tf.int32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=labels,logits=logits)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    cost_correct_positions = cross_entropy * tf.cast(labels,tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    cost_incorrect_positions = cross_entropy * tf.cast((lig_RMSDs > RMSD_threshold), tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    cost_semicorrect_positions = cross_entropy \123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                 * tf.cast((lig_RMSDs < RMSD_threshold), tf.float32) \123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                 * tf.cast((lig_RMSDs > 0.01), tf.float32) * (lig_RMSDs/RMSD_threshold)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return cost_incorrect_positions + cost_semicorrect_positions + cost_correct_positions