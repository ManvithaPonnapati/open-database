import tensorflow as tf123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfrom glob import glob123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport os,time,sys,re,logging,threading123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport numpy as np123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFsys.path.append("../../")123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport affinity.geom123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef decode_av4(file_path):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # read the whole file123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    serialized_record = tf.read_file(file_path)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # decode everything into int32123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    tmp_decoded_record = tf.decode_raw(serialized_record, tf.int32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # first four bytes describe the number of frames in a record123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    number_of_frames = tf.slice(tmp_decoded_record, [0], [1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # labels are saved as int32 * number of frames in the record123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    labels = tf.slice(tmp_decoded_record, [1],number_of_frames)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # elements are saved as int32 and their number is == to the number of atoms123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    number_of_atoms = tf.to_int32((tf.shape(tmp_decoded_record) - number_of_frames - 1) / (3 * number_of_frames + 1))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    elements = tf.slice(tmp_decoded_record, number_of_frames + 1, number_of_atoms)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # coordinates are saved as a stack of X,Y,Z where the first(vertical) dimension123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # corresponds to the number of atoms123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # second (horizontal dimension) is x,y,z coordinate of every atom and is always 3123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # third (depth) dimension corresponds to the number of frames123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    coords_shape = tf.concat([number_of_atoms, [3], number_of_frames], 0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    tmp_coords = tf.slice(tmp_decoded_record, number_of_frames + number_of_atoms + 1,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                          tf.shape(tmp_decoded_record) - number_of_frames - number_of_atoms - 1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    multiframe_coords = tf.bitcast(tf.reshape(tmp_coords, coords_shape), type=tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return labels, elements, multiframe_coords123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef index_vds_database_into_q(db_path,shuffle):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """ Indexes av4 database and returns two lists of filesystem path: ligand files, and protein files.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Ligands are assumed to end with _ligand.av4, proteins should be in the same folders with ligands.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Each protein should have its own folder named similarly to the protein name (in the PDB).123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # TODO controls epochs here123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_file_list = []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    receptor_file_list = []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # for the ligand it's necessary and sufficient to have an underscore in it's name123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print "number of ligands:", len(glob(os.path.join(db_path+'/**/',"*[_]*.av4")))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for ligand_file in glob(os.path.join(db_path+'/**/',"*[_]*.av4")):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        receptor_file = "/".join(ligand_file.split("/")[:-1]) + "/" + ligand_file.split("/")[-1][:4] + '.av4'123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if os.path.exists(receptor_file):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            ligand_file_list.append(ligand_file)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            receptor_file_list.append(receptor_file)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # TODO: remove another naming system from Xiao's scripts                #123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            receptor_file = os.path.join(os.path.dirname(ligand_file),os.path.basename(ligand_file).split("_")[0]+'.av4')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            if os.path.exists(receptor_file):                                       # remove later123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                ligand_file_list.append(ligand_file)                                #123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                receptor_file_list.append(receptor_file)                            #123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    index_list = range(len(ligand_file_list))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    examples_in_database = len(index_list)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if examples_in_database ==0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        raise Exception('av4_input: No files found in the database path:',db_path)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print "Indexed ligand-protein pairs in the database:",examples_in_database123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # create a filename queue (tensor) with the names of the ligand and receptors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    index_tensor = tf.convert_to_tensor(index_list,dtype=tf.int32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_files = tf.convert_to_tensor(ligand_file_list,dtype=tf.string)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    receptor_files = tf.convert_to_tensor(receptor_file_list,dtype=tf.string)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    filename_queue = tf.train.slice_input_producer([index_tensor,ligand_files,receptor_files],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                   num_epochs=None,shuffle=shuffle)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return filename_queue,examples_in_database123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef index_ars_database_into_q(db_path, shuffle):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """ Indexes the PDBBind database using the same method as for the av4 database,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    but with different naming conventions. The ligand file ends in _ligand.av4123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    and the protein file ends in _receptor.av4123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param db_path:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param shuffle:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # TODO logging for debug123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    lig_files = []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_files = []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print "number of (folders) crystal structures:", len(glob(os.path.join(db_path+'/**/')))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for PDB_folder in glob(os.path.join(db_path+'/**/')):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        lig_files_ondisk = glob(os.path.join(PDB_folder,"*_ligand.av4"))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        rec_files_ondisk = np.asarray(glob(os.path.join(PDB_folder,"*_receptor.av4")))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        for lig_file in lig_files_ondisk:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            rec_file = re.sub("_ligand.av4","_receptor.av4",lig_file)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            num_rec_files = np.where(rec_files_ondisk==rec_file)[0].size123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            if num_rec_files is not 1:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                raise Exception('a single receptor for ligand ',lig_file,'is expected',num_rec_files,'found')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                lig_files.append(lig_file)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                rec_files.append(rec_file)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    num_rec_lig_pairs = len(lig_files)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if num_rec_lig_pairs ==0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        raise Exception('av4_input: No files found in the database:',db_path)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        print "number of receptor-ligand pairs in the database:",num_rec_lig_pairs123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        index_list = range(num_rec_lig_pairs)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # create a filename queue (tensor) with the names of the ligand and receptors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    index_list = tf.convert_to_tensor(index_list,dtype=tf.int32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    lig_files = tf.convert_to_tensor(lig_files,dtype=tf.string)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_files = tf.convert_to_tensor(rec_files,dtype=tf.string)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    filename_queue = tf.train.slice_input_producer([index_list,lig_files,rec_files],num_epochs=None,shuffle=shuffle)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return filename_queue,num_rec_lig_pairs123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef index_vrs_database_into_q(db_path, shuffle):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Indexes the filenames of the PDBBind datasets downloaded from DeepChem's 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    AWS servers into a queue. This dataset stores information in NUMPY ARRAYS"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print "Number of (folders) crystal structures:", len(glob(os.path.join(db_path + '/**/')))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    data_files = []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for PDB_folder in glob(os.path.join(db_path + '/**/')):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        data_file = os.path.join(PDB_folder, 'data.npz')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        data_files.append(data_file)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    examples_in_database = len(data_files)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if examples_in_database == 0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        raise Exception("Input: No files found in the database:", db_path)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # create a filename queue (tensor) with the names of the data files123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    index_list = range(examples_in_database)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    index_list = tf.convert_to_tensor(index_list, dtype=tf.int32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    data_files = tf.convert_to_tensor(data_files, dtype=tf.string)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    filename_queue = tf.train.slice_input_producer([index_list, data_files], 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                num_epochs=None, shuffle=shuffle)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return filename_queue, examples_in_database123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef read_data_pdbbind(filename_q):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Reads the data stored in the files from the PDBBind datasets downloaded123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    from the DeepChem's AWS servers (stored in numpy arrays). The data has already123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    been preprocessed so no preprocessing is necessary."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    data_file = filename_q[1]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def my_load(filepath):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        data = np.load(filepath)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        lig_coords = data['ligand_coords']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        lig_nbr_idx = data['ligand_nbr_idx']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        lig_nbr_atoms = data['ligand_nbr_atoms']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        lig_elem = data['ligand_elements']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        rec_coords = data['receptor_coords']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        rec_nbr_idx = data['receptor_nbr_idx']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        rec_nbr_atoms = data['receptor_nbr_atoms']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        rec_elem = data['receptor_elements']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        comp_coords = data['complex_coords']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        comp_nbr_idx = data['complex_nbr_idx']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        comp_nbr_atoms = data['complex_nbr_atoms']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        comp_elem = data['complex_elements']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        label = data['label'] * -1 * 2.479 / 4.184 #convert to deltaG123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return (lig_coords, lig_nbr_idx, lig_nbr_atoms, lig_elem,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF               rec_coords, rec_nbr_idx, rec_nbr_atoms, rec_elem,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF               comp_coords, comp_nbr_idx, comp_nbr_atoms, comp_elem, label)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return tf.py_func(my_load, [data_file], Tout=[tf.float32, tf.int32, tf.int32,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            tf.int32, tf.float32, tf.int32, tf.int32, tf.int32, tf.float32,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            tf.int32, tf.int32, tf.int32, tf.float64])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef read_rec_and_lig_VDS1(filename_q,epoch_counter,lig_frame):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Reads ligand and protein raw bytes based on the names in the filename queue.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param filename_q: filename queue has form [index,ligand_file,protein_file]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                        dtypes= [int32,string,string]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param epoch_counter: int32 variable/tensor that represents current epoch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param lig_frame: a text string of three kinds: ZERO, SEQUENTIAL, and OVERSAMPLING refers to how frames recorded in123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF           VDS1 dataset would be selected.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF           ZERO - always select frame 0 (correct position from the PDB)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF           SEQUENTIAL - select frames in sequence (0->1->2->3)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF           OVERSAMPLING - select either frame 0, or random 1: frame with 50% probability123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Ligand filename, epoch counter, ligand label from file, ligand and receptor elements and coordinates123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # read raw bytes of the ligand and receptor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    idx = filename_q[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    lig_file = filename_q[1]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # decode bytes into meaningful tensors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    lig_labels, lig_elem, multiframe_lig_coord = decode_av4(lig_file)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_labels, rec_elem, multiframe_rec_coord = decode_av4(filename_q[2])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #    Some simple arithmetics is used to sample all of the available frames123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #    if the index of the examle is even, positive label is taken every even epoch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #    if the index of the example is odd, positive label is taken every odd epoch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #    current negative example increments once every two epochs, and slides along all of the negative examples123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if lig_frame == "ZERO":123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # always select oth frame (initial conf) of the ligand123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        current_frame = tf.constant(0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    elif lig_frame == "SEQUENTIAL":123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        current_frame = tf.mod(epoch_counter, tf.shape(lig_labels)[0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    elif lig_frame == "OVERSAMPLING":123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        num_lig_frames = tf.shape(lig_labels)[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        current_frame = tf.cond(tf.equal(tf.mod(epoch_counter + idx + 1, 2), 1),123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                lambda:tf.constant(0),123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                lambda:tf.mod(tf.div(1 + epoch_counter, 2), num_lig_frames - 1) + 1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        raise NotImplementedError('ligand frame sampling method unknown')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    lig_coord = multiframe_lig_coord[:,:,current_frame]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_coord = multiframe_rec_coord[:,:,0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    label = tf.gather(lig_labels,current_frame)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return lig_file,epoch_counter,label,lig_elem,lig_coord,rec_elem,rec_coord123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef read_rec_and_lig_ARS1(filename_q,epoch_counter):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Reads ligand and protein raw bytes based on the names in the filename queue.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param filename_q: filename queue has form [index,ligand_file,protein_file]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                        dtypes= [int32,string,string]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param epoch_counter: int32 variable/tensor that represents current epoch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Ligand filename, epoch counter, ligand label from file, ligand and receptor elements and coordinates123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # read raw bytes of the ligand and receptor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    idx = filename_q[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    lig_file = filename_q[1]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # decode bytes into meaningful tensors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    lig_labels, lig_elem, multiframe_lig_coord = decode_av4(lig_file)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_labels, rec_elem, multiframe_rec_coord = decode_av4(filename_q[2])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #    Some simple arithmetics is used to sample all of the available frames123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #    if the index of the examle is even, positive label is taken every even epoch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #    if the index of the example is odd, positive label is taken every odd epoch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #    current negative example increments once every two epochs, and slides along all of the negative examples123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    if lig_frame == "ZERO":123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#        # always select oth frame (initial conf) of the ligand123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#        current_frame = tf.constant(0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    elif lig_frame == "SEQUENTIAL":123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#        current_frame = tf.mod(epoch_counter, tf.shape(lig_labels)[0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    elif lig_frame == "OVERSAMPLING":123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#        num_lig_frames = tf.shape(lig_labels)[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#        current_frame = tf.cond(tf.equal(tf.mod(epoch_counter + idx + 1, 2), 1),123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#                                lambda:tf.constant(0),123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#                                lambda:tf.mod(tf.div(1 + epoch_counter, 2), num_lig_frames - 1) + 1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#        raise NotImplementedError('ligand frame sampling method unknown')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    lig_frame = tf.constant(0) # always take frame 0 in this file123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    lig_coord = multiframe_lig_coord[:,:,lig_frame]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_coord = multiframe_rec_coord[:,:,0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    label = tf.gather(lig_labels,lig_frame)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return lig_file,epoch_counter,label,lig_elem,lig_coord,rec_elem,rec_coord123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef complex_coords_to_image(ligand_elements,ligand_coords,receptor_elements,receptor_coords,side_pixels,pixel_size,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                            cameraview=None):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Take coordinates and elements of protein and ligand and convert them into an image.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Return image with one dimension so far."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # FIXME abandon ligand when it does not fit into the box (it's kept now)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # max_num_attempts - maximum number of affine transforms for the ligand to be tried123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    max_num_attemts = 1000                      # TODO this should happen on the level of data preparation123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # affine_transform_pool_size is the first(batch) dimension of tensor of transition matrices to be returned123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # affine tranform pool is only generated once in the beginning of training and randomly sampled afterwards123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    affine_transform_pool_size = 10000123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # transform center ligand around zero123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_center_of_mass = tf.reduce_mean(ligand_coords, reduction_indices=0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    centered_ligand_coords = ligand_coords - ligand_center_of_mass123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    centered_receptor_coords = receptor_coords - ligand_center_of_mass123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # use TF while loop to find such an affine transform matrix that can fit the ligand so that no atoms are outside123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    box_size = (tf.cast(side_pixels, tf.float32) * pixel_size)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def generate_transition_matrix(attempt,cameraview,random_cameraviews):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """Takes initial coordinates of the ligand, generates a random affine transform matrix and transforms coordinates."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        cameraview= tf.gather(random_cameraviews,tf.random_uniform([], minval=0, maxval=affine_transform_pool_size-1,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                   dtype=tf.int32))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        attempt += 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return attempt,cameraview,random_cameraviews123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def not_all_in_the_box(attempt,cameraview,random_cameraviews,ligand_coords=centered_ligand_coords,box_size=box_size,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                           max_num_attempts=max_num_attemts):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """Takes affine transform matrix and box dimensions, performs the transformation, and checks if all atoms123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        are in the box."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        transformed_coords,cameraview = affinity.geom.affine_tform(ligand_coords,cameraview)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        not_all = tf.cast(tf.reduce_max(tf.cast(tf.square(box_size*0.5) - tf.square(transformed_coords) < 0,tf.int32)),123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                          tf.bool)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        within_iteration_limit = tf.cast(tf.reduce_sum(tf.cast(attempt < max_num_attemts, tf.float32)), tf.bool)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return tf.logical_and(within_iteration_limit, not_all)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    attempt = tf.Variable(tf.constant(0, shape=[1]))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    random_cameraviews = tf.Variable(affinity.geom.gen_affine_tform(affine_transform_pool_size))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if cameraview is None:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        cameraview = tf.gather(random_cameraviews, tf.random_uniform([], minval=0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                     maxval=affine_transform_pool_size, dtype=tf.int64))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        cameraview = cameraview123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    last_attempt,final_cameraview,_ = tf.while_loop(not_all_in_the_box, generate_transition_matrix,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                    [attempt,cameraview,random_cameraviews],parallel_iterations=1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # rotate receptor and ligand using an affine transform matrix found123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rotatated_ligand_coords,_ = affinity.geom.affine_tform(centered_ligand_coords,final_cameraview)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rotated_receptor_coords,_ = affinity.geom.affine_tform(centered_receptor_coords,final_cameraview)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # TODO: this should be an error: move this function to the level of data preparation123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # check if all of the atoms are in the box, if not set the ligand to 0, but do not raise an error123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    def set_elements_coords_zero(): return tf.constant([0],dtype=tf.int32),tf.constant([[0,0,0]],dtype=tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    def keep_elements_coords(): return ligand_elements,rotatated_ligand_coords123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    not_all = tf.cast(tf.reduce_max(tf.cast(tf.square(box_size * 0.5) - tf.square(rotatated_ligand_coords) < 0, tf.int32)),123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                      tf.bool)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    ligand_elements,rotatated_ligand_coords = tf.case({tf.equal(not_all,tf.constant(True)):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#                                                           set_elements_coords_zero},keep_elements_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # TODO: maybe throw an error when things don't fit ??123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # move coordinates of a complex to an integer number so as to put every atom on a grid123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # ceiled coords is an integer number out of real coordinates that corresponds to the index on the cell123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # epsilon - potentially, there might be very small rounding errors leading to additional indexes123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    epsilon = tf.constant(0.999,dtype=tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ceiled_ligand_coords = tf.cast(tf.round((-0.5 + (tf.cast(side_pixels,tf.float32)*0.5) +123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                             (rotatated_ligand_coords/pixel_size))*epsilon),tf.int64)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ceiled_receptor_coords = tf.cast(tf.round((-0.5 + (tf.cast(side_pixels, tf.float32) * 0.5) +123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                               (rotated_receptor_coords/pixel_size))*epsilon),tf.int64)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # crop atoms of the protein that do not fit inside the box123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    top_filter = tf.reduce_max(ceiled_receptor_coords,reduction_indices=1)<side_pixels123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    bottom_filter = tf.reduce_min(ceiled_receptor_coords,reduction_indices=1)>0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    retain_atoms = tf.logical_and(top_filter,bottom_filter)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    cropped_receptor_coords = tf.boolean_mask(ceiled_receptor_coords,retain_atoms)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    cropped_receptor_elements = tf.boolean_mask(receptor_elements,retain_atoms)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #FIXME: remove hydrogens123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #FIXME: put ligand and protein each into a separate layers of depth123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # FIXME: cropping and matmul123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # matmul is to escape bug within tensorflow when a boolean mask of undefined shape can not be used123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_hydrogen_mask = tf.cast(tf.matmul(tf.transpose([ligand_elements],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                          perm=[1, 0]), tf.ones([1, 1], tf.int32))[:, 0] > 1, tf.bool)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_elements_noh = tf.boolean_mask(ligand_elements,ligand_hydrogen_mask)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_coords_noh = tf.boolean_mask(ceiled_ligand_coords,ligand_hydrogen_mask)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    receptor_hydrogen_mask = tf.cast(tf.matmul(tf.transpose([cropped_receptor_elements],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                            perm=[1, 0]), tf.ones([1, 1], tf.int32))[:, 0] > 1, tf.bool)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    receptor_elements_noh = tf.boolean_mask(cropped_receptor_elements,receptor_hydrogen_mask)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    receptor_coords_noh = tf.boolean_mask(cropped_receptor_coords,receptor_hydrogen_mask)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    complex_coords = tf.concat([ligand_coords_noh,receptor_coords_noh],0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    complex_elements = tf.concat([ligand_elements_noh+7,receptor_elements_noh],0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # FIXME: validate indices = True123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    sparse_complex = tf.SparseTensor(indices=complex_coords, values=tf.to_float(complex_elements),123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                     dense_shape=[side_pixels, side_pixels, side_pixels])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ordered_sparse_complex = tf.sparse_reorder(sparse_complex)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    complex_image = tf.sparse_tensor_to_dense(ordered_sparse_complex,validate_indices=False)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return complex_image,ligand_center_of_mass,final_cameraview123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef image_and_label_q(batch_size,pixel_size,side_pixels,num_threads,filename_q,epoch_counter,lig_frame):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Creates shuffle queue for training the network"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # read one receptor and stack of ligands; choose one of the ligands from the stack according to epoch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_file,current_epoch,label,ligand_elements,ligand_coords,receptor_elements,receptor_coords = read_rec_and_lig(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        filename_q,epoch_counter=epoch_counter,lig_frame=lig_frame)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # convert coordinates of ligand and protein into an image123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    dense_image,_,_ = complex_coords_to_image(ligand_elements,ligand_coords,receptor_elements,receptor_coords,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                              side_pixels,pixel_size)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # create a batch of proteins and ligands to read them together123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    multithread_batch = tf.train.batch([ligand_file,current_epoch, label, dense_image], batch_size,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                       num_threads=num_threads,capacity=batch_size * 3,dynamic_pad=True,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                       shapes=[[],[], [], [side_pixels,side_pixels,side_pixels]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return multithread_batch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef crop_binding_site(lig_coord,rec_elem,rec_coord,crop_radii):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Centers view on the center of mass of the ligand. Crops away atoms of the receptor that are further than crop_radii123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    from center of mass of the ligand.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param lig_coord: float32 coordinates of atoms of the ligand123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param rec_elem: int32 elements of the receptor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param rec_coord: float32 coordinates of atom of receptor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param crop_radii: float32123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return: cropped coordinates and elements of the receptor.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # FIXME: raise exception if the ligand itself does not fit123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    lig_center = tf.reduce_mean(lig_coord,0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_coord = rec_coord - lig_center123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_retain = tf.reduce_sum(rec_coord **2,1) < crop_radii**2123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_elem = tf.boolean_mask(rec_elem,rec_retain)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_coord = tf.boolean_mask(rec_coord,rec_retain)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_coord = rec_coord + lig_center123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return rec_elem,rec_coord123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef data_and_label_queue(batch_size, num_threads, filename_queue, epoch_counter):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Creates shuffle queue for training the network123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Returns batches with ligand, receptor, and complex 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Data for coordinates, neighbor indices and neighbor corresponding atoms"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def preprocess(atoms, coords):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """Constructs a matrix of nearest neighbors for each atom, along with the 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        corresponding atom types."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        #define the rank of the atoms and coords123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        atoms = tf.reshape(atoms, [-1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        coords = tf.reshape(coords, [-1, 3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        point_pairs, rel_coords = af.geom.pointcloud_pairlist(coords, coords, cutoffs_xyz=tf.constant([12,12,12],dtype=tf.int32), order='DIST')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        neighbor_idx = create_neighbor_list(coords, point_pairs, 8+1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        neighbor_atoms = tf.gather(atoms, neighbor_idx)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return tf.cast(neighbor_idx, tf.int32), tf.cast(neighbor_atoms, tf.int32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def create_neighbor_list(srcpnt_coords,point_pairs,num_neighbors):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        src_pairs = point_pairs[:,0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        dest_pairs = point_pairs[:,1]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        num_srcpnt = tf.shape(srcpnt_coords)[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        num_pairs = tf.shape(src_pairs)[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        table_shape = tf.to_int64(tf.stack([num_neighbors, num_srcpnt]))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # if any of the source points has more neighbors than requested, crop them123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        nhbr_per_srcpnt = tf.segment_sum(tf.ones([num_pairs],tf.int32),src_pairs)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        nhbr_idx = af.c_lib.int_sequence(tf.zeros([num_srcpnt], tf.int32), nhbr_per_srcpnt)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        nhbr_fits_table = nhbr_idx < num_neighbors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        nhbr_idx = tf.boolean_mask(nhbr_idx,nhbr_fits_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        src_pairs = tf.boolean_mask(src_pairs,nhbr_fits_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        dest_pairs = tf.boolean_mask(dest_pairs,nhbr_fits_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # convert lists of neighboring points; 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # if some of the points do not have enogh neighbors, pad with 0s123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        table_indices = tf.concat([tf.to_int64(tf.expand_dims(nhbr_idx,1)),tf.expand_dims(src_pairs,1)],1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        table_values = tf.to_int64(dest_pairs) #got rid of adding 1 part123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        nhbr_table = tf.SparseTensor(table_indices,table_values, dense_shape=table_shape)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        nhbr_table = tf.sparse_reorder(nhbr_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        nhbr_table = tf.sparse_tensor_to_dense(nhbr_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        nhbr_table = tf.transpose(nhbr_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return nhbr_table123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def crop_binding_site(ligand_coords, receptor_atoms, receptor_coords):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """Subroutine for data_and_label_queue. Crops the receptor atoms so that only123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        atoms near the binding site are considered."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        #transform ligand and receptor atoms around CM123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        ligand_cm = tf.reduce_mean(ligand_coords, reduction_indices=0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        ligand_coords = ligand_coords - ligand_cm123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        receptor_coords = receptor_coords - ligand_cm123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        max_coords = tf.reduce_max(ligand_coords, reduction_indices=0) + 8123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        min_coords = tf.reduce_min(ligand_coords, reduction_indices=0) - 8123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        retain_atoms = tf.logical_and(receptor_coords < max_coords, receptor_coords > min_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        retain_atoms = tf.reduce_all(retain_atoms, axis=1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        retain_atoms.set_shape(receptor_atoms.shape)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        cropped_receptor_coords = tf.boolean_mask(receptor_coords, retain_atoms)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        cropped_receptor_atoms = tf.boolean_mask(receptor_atoms, retain_atoms)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return cropped_receptor_atoms, cropped_receptor_coords123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #read data, and crop atoms outside of binding site123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_file, current_epoch, label, ligand_atoms, ligand_coords, receptor_atoms, receptor_coords = read_rec_and_lig(filename_queue, epoch_counter=epoch_counter, lig_frame='OVERSAMPLING')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    receptor_atoms, receptor_coords = crop_binding_site(ligand_coords, receptor_atoms, receptor_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #create the complex by combining the ligand and receptor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    complex_atoms = tf.concat([ligand_atoms, receptor_atoms], axis=0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    complex_coords = tf.concat([ligand_coords, receptor_coords], axis=0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    complex_idx, complex_atoms = preprocess(complex_atoms, complex_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    receptor_idx, receptor_atoms = preprocess(receptor_atoms, receptor_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_idx, ligand_atoms = preprocess(ligand_atoms, ligand_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    multithread_batch = tf.train.batch([ligand_file, current_epoch, label,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        ligand_coords, ligand_idx, ligand_atoms, 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        receptor_coords, receptor_idx, receptor_atoms,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        complex_coords, complex_idx, complex_atoms],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        batch_size, num_threads, capacity=batch_size*3, dynamic_pad=True, 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        shapes=[[],[],[], [None,3], [None,8+1], [None,8+1], [None,3], [None,8+1], [None,8+1], [None,3], [None,8+1], [None,8+1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return multithread_batch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF