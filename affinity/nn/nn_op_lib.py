import tensorflow as tf123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport numpy as np123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport logging123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef _matmul_point_pairs_by_kernel(k_size,pix_size,w,sd_pairs,sd_rel_coords,s_feat,d_feat):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    d_features will be concatenated to s_features when given123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param k_size: shape of the kernel in 3D123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param pix_size:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param point_pairs: interaction pair = -1 point pair is reserved for zero_neighbor situation123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param rel_coords:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param kernel: 0 0 0 of the kernel is reserved for zero_neighbor situation123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param d_features:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param s_features:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # todo assert shapes123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    k_size = np.asarray(k_size,dtype=np.int32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    logging.debug("tf.gather index verification while running GPU is not yet possible "123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                  "Please, test on CPUs first.")123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    no_nhbr_feat =tf.expand_dims(tf.ones(d_feat.get_shape()[1]),0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    d_feat = tf.concat([no_nhbr_feat,d_feat],0) # feature for zero_neighbors = -1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    s_feat = tf.gather(s_feat,sd_pairs[:,0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    d_feat = tf.gather(d_feat,sd_pairs[:,1]+1) # +1 is to account for zero_neighbors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    feature_pairs = tf.concat([s_feat,d_feat], axis=1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # find indices on the flattened kernel to gather/slice123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    k_gatheridx = tf.cast((sd_rel_coords / pix_size) + (k_size/2) + 0.5,tf.int32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # converting index in 3D into index 1D (flat) kernel123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    k_gatheridx = tf.reduce_sum(k_gatheridx * np.stack([k_size[0] * k_size[1], k_size[1], 1]),1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # gather slices of the kernels123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    k_shards = tf.gather(w,k_gatheridx)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    convout = tf.matmul(tf.expand_dims(feature_pairs,1),k_shards)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    convout = convout[:, 0, :] # squeezing the empty central dimension123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return convout123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef _compute_feature_distance_matrix(atom_features, nbr_idx, neighbors):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param atom_features:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param nbr_idx:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param neighbors:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #gather the corresponding features of the neighbors for each atom123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    nbr_features = tf.gather(atom_features, nbr_idx)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #compute the distance matrix between each atom and neighbor features123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    feature_dist = tf.expand_dims(atom_features, axis=1) - nbr_features123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    feature_dist = tf.sqrt(tf.reduce_sum(tf.square(feature_dist), axis=2))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return feature_dist123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef _radial_filter(filter_means, filter_stds, distance_matrix, source_atoms, nbr_atoms, 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    atom_mask, atom_types=9, radial_cutoff=12, radial_scaling=1.0, radial_bias=0.0):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param filter_means:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param filter_stds:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param distance_matrix:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param source_atoms:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param nbr_atoms:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param atom_mask:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param atom_types:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param radial_cutoff:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param radial_scaling:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param radial_bias:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #distance matrix: [N, M]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #embed the correct filters - one per source/dest atom type pair123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    param_selector = tf.expand_dims(source_atoms, -1) * (atom_types+1) + nbr_atoms123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    embed_means = tf.nn.embedding_lookup(params=filter_means, ids=param_selector)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    embed_stds = tf.nn.embedding_lookup(params=filter_stds, ids=param_selector)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #apply the Gaussian filters to create the corresponding output123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    distance_matrix = tf.expand_dims(distance_matrix, axis=-1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    distances_filtered = tf.exp(-((distance_matrix-embed_means)/embed_stds) ** 2)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #apply radial cutoff function and zeros activations for "nonexistent padded atoms"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    distances_filtered *= tf.cos(np.pi * distance_matrix / radial_cutoff)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    distances_filtered *= tf.expand_dims(tf.cast(atom_mask, tf.float32), -1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    distances_filtered *= tf.cast(tf.logical_and(distance_matrix > 0, distance_matrix < radial_cutoff), tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    distances_filtered = distances_filtered * tf.constant(radial_scaling) + tf.constant(radial_bias)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return distances_filtered123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef _atom_type_one_hot_expansion(distances_filtered, corr_atoms, atom_types=9):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param distances_filtered:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param corr_atoms:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param atom_types:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #distances_filtered: [N, M, Nr]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #corr_atoms: [N, M]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    atoms_one_hot = tf.expand_dims(tf.one_hot(corr_atoms, atom_types+1)[:, :, 1:], 2)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    distances_expanded = tf.multiply(tf.expand_dims(distances_filtered, -1), atoms_one_hot)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return distances_expanded