import re,random,time,prody,threading123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport numpy as np123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport tensorflow as tf123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfrom av2_atomdict import atom_dictionary123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# todo solve the problem when many atoms are coming into the same box123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# todo add from rdkit or pytraj or openeye to support mol files123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# todo add logger123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# todo update dictionary123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# todo add some way to generate PDBs from vectors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# script currently works the following way:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# 1 ) ligand atom coordinates are read into the matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# 2 ) ligand atom coordinates are centered on zero123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# 3 ) box is rotated ( in reality, it was easier to transform ligand cordinates) until all ligand atoms can fit123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# 4 ) protein is read and transformed with the same affine transform123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# 5 ) 3D tensor of zeros is generated123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# 6 ) Coordinates of every atom are rounded  (ceiled coordinates)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF# 7 ) number from atom vocabulary is written as pixel in place of 0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef generate_random_transition_matrix(shift_range=10,rotation_range=np.pi*2):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """returns a random transition matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rotation range - determines random rotations along any of X,Y,Z axis123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    shift_range determines allowed shifts along any of X,Y,Z axis """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # randomly shift along X,Y,Z123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    xyz_shift_matrix = np.matrix([[1 ,0 , 0, random.random()*shift_range],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                 [0, 1, 0, random.random()*shift_range],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                 [0, 0, 1, random.random()*shift_range],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                 [0, 0, 0, 1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ## randomly rotate along X123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rand_x = random.random()*rotation_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    x_rotate_matrix = np.matrix([[1, 0, 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                               [0, np.cos(rand_x), - np.sin(rand_x), 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                               [0, np.sin(rand_x), np.cos(rand_x), 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                [0, 0, 0, 1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ## randomly rotate along Y123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rand_y = random.random()*rotation_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    y_rotate_matrix = np.matrix([[np.cos(rand_y), 0, np.sin(rand_y), 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                [0, 1, 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                [-np.sin(rand_y), 0, np.cos(rand_y), 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                [0, 0 ,0 ,1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ## randomly rotate along Z123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rand_z = random.random()*rotation_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    z_rotate_matrix = np.matrix([[np.cos(rand_z), -np.sin(rand_z), 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                               [np.sin(rand_z), np.cos(rand_z), 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                               [0, 0, 1, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                [0, 0, 0, 1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # combining all matrices into one by multiplication123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # nice property of the matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    xyz_rotate_shift_matrix =  xyz_shift_matrix * x_rotate_matrix * y_rotate_matrix * z_rotate_matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return xyz_rotate_shift_matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#def affine_transform(coordinate_array,transition_matrix):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    """applies transition to every point in array"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    def transform_one_point(one_point,transition_matrix=transition_matrix):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#        return np.sum(transition_matrix * np.matrix(np.append(one_point,1)).transpose(),axis=1)[0:3]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    transformed_coordinates = np.array(map(transform_one_point,coordinate_array[:,0:3])).reshape(-1,3)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    return transformed_coordinates123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef affine_transform(coordinate_array,transition_matrix):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """applies transition to every point of the array"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #print "FLAG1"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    matrix_coord = np.matrix(coordinate_array)    # np.matrix has different defaults compared to np.array123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #print "matrix_coord", matrix_coord123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #print "FLAG2"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    raw_of_ones = np.matrix(np.ones(len(matrix_coord[:,0])))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #print "raw_of_ones",raw_of_ones123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #print "FLAG3"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    transformed_coord = (transition_matrix * np.vstack((matrix_coord.transpose(),raw_of_ones)))[0:3,:].transpose()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return np.array(transformed_coord)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef generate_image(ligand_filename,receptor_filename,pixel_size=1,side_pixels=20,num_attempts=1000):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """generates 3d tensor from file"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def if_in_the_box(atom_coord,box_edge = pixel_size * side_pixels):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        "checks if the atom will fall into the cubic box of size box_edge around [0 0 0]"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if (-0.5*box_edge < atom_coord[0] < 0.5*box_edge) \123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                and (-0.5*box_edge < atom_coord[1] < 0.5*box_edge) \123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                and (-0.5*box_edge < atom_coord[2] < 0.5*box_edge):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            return True123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            return False123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    prody_ligand = prody.parsePDB(ligand_filename)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # center the coordinates of the ligand around [ 0 0 0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_center_of_mass = prody.calcCenter(prody_ligand)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    prody_ligand.setCoords(prody_ligand.getCoords() - ligand_center_of_mass)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # find transition matrix that could fit all the ligand atoms123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    final_transition_matrix = False123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for attempt in range(num_attempts):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        print "attempt:",attempt123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # make a random transition matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        random_transition_matrix = generate_random_transition_matrix()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # affine transform123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        transformed_ligand_coord = affine_transform(prody_ligand.getCoords(),random_transition_matrix)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # see if all ligand atoms are in the box123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if all(map(if_in_the_box,transformed_ligand_coord[:,0:3])):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            final_transition_matrix = random_transition_matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            break123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # check if attempt to generate the transition matrix was successful123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # if not, exit procedure123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if isinstance(final_transition_matrix, bool):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        print "reached maximum number of attempts and failed", num_attempts123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return False123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # if script goes past this point, it means transition matrix for the box to fit all ligand atoms was generated123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # transform ligand to the new coordinate system (only do it once)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    prody_ligand.setCoords(affine_transform(prody_ligand.getCoords(), final_transition_matrix))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # parse the protein123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # instead of parsing receptor (old slow version), script will be reading numpy arrays123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # prody_receptor = prody.parsePDB(receptor_filename)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    receptor_filename = re.sub('.pdb$', '', receptor_filename)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #print receptor_filename + '_coor.npy'123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #print np.load(receptor_filename + '_coor.npy')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #print np.load(receptor_filename + '_elem.npy')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    prody_receptor = prody.AtomGroup()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    prody_receptor.setCoords(np.load(receptor_filename + '_coor.npy'))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    prody_receptor.setElements(np.load(receptor_filename + '_elem.npy'))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # now prody_receptor is the same prody object as prody_ligand123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # shift coordinates of the protein the same way as for thr ligand123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    prody_receptor.setCoords(prody_receptor.getCoords() -ligand_center_of_mass)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # transform the protein (only do it once)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    prody_receptor.setCoords(affine_transform(prody_receptor.getCoords(), final_transition_matrix))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # write protein and ligand into 3d tensor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # round coordinates before mapping to cells123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ceiled_ligand_coord = np.asarray(np.round(prody_ligand.getCoords()/pixel_size - 0.5 + side_pixels/2),dtype=int)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ceiled_receptor_coord = np.asarray(np.round(prody_receptor.getCoords() / pixel_size - 0.5 + side_pixels / 2),dtype=int)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # map to cells in 3D tensor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    tensor_3d = np.zeros((side_pixels,)*3)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def mark_atom_on_tensor(ceiled_atom_coord,atomname,if_ligand,tensor_3d=tensor_3d):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """receives atomnames and ceiled coordinate. 1) Converts atomname into number 2) writes123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        this number into corresponding bit in 3D tensor"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return np.zeros(20,20,20)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        #if if_ligand:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            #atomic_tag_number = atom_dictionary.LIG[atomname.lower()]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            #tensor_3d[zip(np.ndarray.tolist(ceiled_atom_coord))] = atomic_tag_number123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        #else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # check if the coordinate is in the box123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            #if (0 < ceiled_atom_coord[0] < 20) \123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            #        and (0 < ceiled_atom_coord[1] < 20) \123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            #        and (0 < ceiled_atom_coord[2] < 20):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                    #len(tensor_3d[0][0][:])):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                # if it is, add atom tag to the tensor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                #atomic_tag_number = 1 #atom_dictionary.REC[atomname.lower()]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                #tensor_3d[zip(np.ndarray.tolist(ceiled_atom_coord))] = atomic_tag_number123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # map ligand on 3d tensor first123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #map(mark_atom_on_tensor, ceiled_ligand_coord[:, 0:3],prody_ligand.getElements(),np.ones(prody_ligand.numAtoms()))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # map the protein on 3d tensor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #map(mark_atom_on_tensor, ceiled_receptor_coord[:, 0:3], prody_receptor.getElements(), np.zeros(prody_receptor.numAtoms()))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return tensor_3d123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # test and write transformed coordinates to the pdb file123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # print "ligand:",len(prody_ligand.getCoords()[:,0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # print "ceiled:",len(ceiled_ligand_coord[:,0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # prody_ligand.setCoords(np.asarray(ceiled_ligand_coord*pixel_size,dtype=float))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # prody_receptor.setCoords(np.asarray(ceiled_receptor_coord*pixel_size,dtype=float))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # prody.writePDB("debug_ligand",prody_ligand)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # prody.writePDB("debug_protein",prody_receptor)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef launch_enqueue_workers(sess,coord,data_dir,pixel_size,side_pixels,num_workers,batch_size):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """launch many threads to fill the queue in the backgrund. Gracefully close after specified amount of batches123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    maintains two separate queues 1 - Image queue 2 - Filename queue """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # launch one thread in the background to read the database index file123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    database_index_file = tf.train.string_input_producer(["train_set.csv"])                                            # todo - change name123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    reader = tf.TextLineReader()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    _, one_file = reader.read(database_index_file)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    col1, col2, col3 = tf.decode_csv(one_file, record_defaults=[[0], ["some_string"], ["some_string"]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    filename_queue = tf.FIFOQueue(num_workers*5, [tf.int32, tf.string, tf.string], shapes=[[], [], []])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    enqueue_filename_op = filename_queue.enqueue([col1, col2, col3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    label,ligand_filepath,protein_filepath = filename_queue.dequeue()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def filename_queue_worker(coord):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        while not coord.should_stop():123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            sess.run([col1, col2, col3, enqueue_filename_op])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    filename_enqueue_thread = threading.Thread(target=filename_queue_worker, args=(coord,))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    filename_enqueue_thread.start()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # now, when background thread is running, I can generate image tensors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # file location for multiple image_workers is pulled from filename_queue123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    image_queue = tf.FIFOQueue(5, [tf.int32,tf.float32], shapes=[[],[side_pixels,side_pixels,side_pixels]])   #todo add _batch_size123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    feed_label = tf.placeholder(tf.int32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    feed_image = tf.placeholder(tf.float32,shape=[side_pixels,side_pixels,side_pixels])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    enqueue_image_op = image_queue.enqueue([feed_label,feed_image])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def image_queue_worker(coord,worker_name):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        while not coord.should_stop():123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            mylabel,myligand_filepath,myreceptor_filepath = sess.run([label,ligand_filepath,protein_filepath])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            myimage = generate_image(ligand_filename=myligand_filepath, receptor_filename=myreceptor_filepath,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                   pixel_size=pixel_size, side_pixels=side_pixels)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            print "worker:",worker_name,"added image to the queue"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            sess.run([enqueue_image_op],feed_dict={feed_label:mylabel,feed_image:myimage})123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            if False:                                                                                            # todo add stop_rule to all threads123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                coord.request_stop()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #with tf.device("/cpu:1"):                                                                                  #todo testing many CPUs123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                                                                # todo visualization of many queue workers123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    image_enqueue_threads = [threading.Thread(target=image_queue_worker,args=(coord,worker_name,)) for worker_name in xrange(num_workers)]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for t in image_enqueue_threads:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        print "thread started:",t123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        t.start()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        time.sleep(0.05)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return image_queue123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFsess = tf.Session()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFcoord = tf.train.Coordinator()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimage_queue = launch_enqueue_workers(sess=sess,coord=coord,data_dir="home",pixel_size=1,side_pixels=20,num_workers=16,batch_size=100)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFthreads = tf.train.start_queue_runners(coord=coord, sess=sess)                                          # todo: move the thread coordinator further away123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdequeue_image_op = image_queue.dequeue_many(100)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFwhile True:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    start_time = time.time()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    sess.run([dequeue_image_op])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    speed_test = str(("dequeue speed test:","%.2f" % (100 / (time.time() - start_time)),"\n"))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    my_log_file = open("./av2_log", "a")123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    my_log_file.writelines(speed_test)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    my_log_file.close()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print speed_test123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print "--------------------------------------------------------------------------------------------------------"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFprint "done !"