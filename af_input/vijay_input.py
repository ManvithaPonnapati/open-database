import tensorflow as tf123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfrom glob import glob123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport os,time,sys123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFsys.path.append('../')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport affinity as af123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#note: we preset neighbors = 8 and radial_cutoff = 12123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef data_and_label_queue(batch_size, num_threads, filename_queue, epoch_counter):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	"""Creates shuffle queue for training the network"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	#read data, and crop atoms outside of binding site123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	ligand_file, current_epoch, label, ligand_atoms, ligand_coords, receptor_atoms, receptor_coords = af.input.read_receptor_and_ligand(filename_queue, epoch_counter=epoch_counter, lig_frame='OVERSAMPLING')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	receptor_atoms, receptor_coords = crop_binding_site(ligand_coords, receptor_atoms, receptor_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	#create the complex by combining the ligand and receptor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	complex_atoms = tf.concat([ligand_atoms, receptor_atoms], axis=0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	complex_coords = tf.concat([ligand_coords, receptor_coords], axis=0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	complex_idx, complex_atoms = preprocess(complex_atoms, complex_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	receptor_idx, receptor_atoms = preprocess(receptor_atoms, receptor_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	ligand_idx, ligand_atoms = preprocess(ligand_atoms, ligand_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	multithread_batch = tf.train.batch([ligand_file, current_epoch, label,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF		ligand_coords, ligand_idx, ligand_atoms, 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF		receptor_coords, receptor_idx, receptor_atoms,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF		complex_coords, complex_idx, complex_atoms],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF		batch_size, num_threads, capacity=batch_size*3, dynamic_pad=True, 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF		shapes=[[],[],[], [None,3], [None,8+1], [None,8+1], [None,3], [None,8+1], [None,8+1], [None,3], [None,8+1], [None,8+1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	return multithread_batch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef preprocess(atoms, coords):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	"""Constructs a matrix of nearest neighbors for each atom, along with the 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	corresponding atom types."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	#define the rank of the atoms and coords123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	atoms = tf.reshape(atoms, [-1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	coords = tf.reshape(coords, [-1, 3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	point_pairs, rel_coords = af.geom.pointcloud_pairlist(coords, coords, cutoffs_xyz=tf.constant([12,12,12],dtype=tf.int32), order='DIST')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	neighbor_idx = create_neighbor_list(coords, point_pairs, 8+1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	neighbor_atoms = tf.gather(atoms, neighbor_idx)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	return tf.cast(neighbor_idx, tf.int32), tf.cast(neighbor_atoms, tf.int32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef create_neighbor_list(srcpnt_coords,point_pairs,num_neighbors):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    src_pairs = point_pairs[:,0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    dest_pairs = point_pairs[:,1]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    num_srcpnt = tf.shape(srcpnt_coords)[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    num_pairs = tf.shape(src_pairs)[0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    table_shape = tf.to_int64(tf.stack([num_neighbors, num_srcpnt]))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # if any of the source points has more neighbors than requested, crop them123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    nhbr_per_srcpnt = tf.segment_sum(tf.ones([num_pairs],tf.int32),src_pairs)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    nhbr_idx = af.c_lib.int_sequence.int_sequence(tf.zeros([num_srcpnt], tf.int32), nhbr_per_srcpnt)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    nhbr_fits_table = nhbr_idx < num_neighbors123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    nhbr_idx = tf.boolean_mask(nhbr_idx,nhbr_fits_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    src_pairs = tf.boolean_mask(src_pairs,nhbr_fits_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    dest_pairs = tf.boolean_mask(dest_pairs,nhbr_fits_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # convert lists of neighboring points; 123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # if some of the points do not have enogh neighbors, pad with 0s123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    table_indices = tf.concat([tf.to_int64(tf.expand_dims(nhbr_idx,1)),tf.expand_dims(src_pairs,1)],1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    table_values = tf.to_int64(dest_pairs) #got rid of adding 1 part123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    nhbr_table = tf.SparseTensor(table_indices,table_values, dense_shape=table_shape)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    nhbr_table = tf.sparse_reorder(nhbr_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    nhbr_table = tf.sparse_tensor_to_dense(nhbr_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    nhbr_table = tf.transpose(nhbr_table)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return nhbr_table123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef crop_binding_site(ligand_coords, receptor_atoms, receptor_coords):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	"""Subroutine for data_and_label_queue. Crops the receptor atoms so that only123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	atoms near the binding site are considered."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	#transform ligand and receptor atoms around CM123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	ligand_cm = tf.reduce_mean(ligand_coords, reduction_indices=0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	ligand_coords = ligand_coords - ligand_cm123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	receptor_coords = receptor_coords - ligand_cm123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	max_coords = tf.reduce_max(ligand_coords, reduction_indices=0) + 8123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	min_coords = tf.reduce_min(ligand_coords, reduction_indices=0) - 8123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	retain_atoms = tf.logical_and(receptor_coords < max_coords, receptor_coords > min_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	retain_atoms = tf.reduce_all(retain_atoms, axis=1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	retain_atoms.set_shape(receptor_atoms.shape)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	cropped_receptor_coords = tf.boolean_mask(receptor_coords, retain_atoms)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	cropped_receptor_atoms = tf.boolean_mask(receptor_atoms, retain_atoms)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF	return cropped_receptor_atoms, cropped_receptor_coords123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF