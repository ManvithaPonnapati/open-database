from PIL import Image, ImageDraw123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfrom random import randint123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport numpy as np123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport math123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport Flags123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef shape(id, which):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    name = ""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    im = Image.new('RGB', (Flags.DIM, Flags.DIM))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    while not stable(im):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        im = Image.new('RGB', (Flags.DIM, Flags.DIM))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        shapeName = ""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if which == 0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            im = ellipse(im)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            shapeName = "ellipse"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        elif which == 1:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            im = triangle(im)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            shapeName = "triangle"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        elif which == 2:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            im = square(im)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            shapeName = "square"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        im = cut(im)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        name = "images/" + str(id) + "." + shapeName + ".png"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # name = str(id) + "." + shapeName123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # return (im, name)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    im.save(name)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # im.show()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef ellipse(im, xBoundMin=math.floor(0.2 * Flags.DIM), xBoundMax=math.floor(0.8 * Flags.DIM), yBoundMin=math.floor(0.2 * Flags.DIM), yBoundMax=math.floor(0.8 * Flags.DIM)):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Generate random bounds of ellipse based on inputs123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    x, y = im.size123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    eX, eY = randint(xBoundMin, xBoundMax), randint(yBoundMin, yBoundMax)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Draw ellipse123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    bbox = (x / 2 - eX / 2, y / 2 - eY / 2, x / 2 + eX / 2, y / 2 + eY / 2)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw = ImageDraw.Draw(im)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw.ellipse(bbox, fill=128, outline=128)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    del draw123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return im123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef triangle(im, size=0.78 * Flags.DIM):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Generate a roughly equilateral triangle123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    size = Flags.DIM - size123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    vertices = [(size, Flags.DIM - size), (Flags.DIM - size, Flags.DIM - size), (Flags.DIM / 2, size)]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Rotate it anywhere from 0 to 2pi radians123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    vertices = rotate(vertices, randint(0, 360) * math.pi / 180)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Draw it on the image123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw = ImageDraw.Draw(im)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw.polygon(vertices, fill=128, outline=128)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    del draw123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return im123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef square(im, size=0.2 * Flags.DIM):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Generate a square123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    vertices = [(Flags.DIM / 2 - size, Flags.DIM / 2 - size), (Flags.DIM / 2 - size, Flags.DIM / 2 + size), (Flags.DIM / 2 + size, Flags.DIM / 2 + size), (Flags.DIM / 2 + size, Flags.DIM / 2 - size)]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Rotate it anywhere from 0 to 2pi radians123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    vertices = rotate(vertices, randint(0, 360) * math.pi / 180)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Draw it on the image123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw = ImageDraw.Draw(im)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw.polygon(vertices, fill=128, outline=128)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    del draw123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return im123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef rotate(points, angle):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    result = list()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rotation_matrix = np.matrix([[math.cos(angle), 0 - math.sin(angle)], [math.sin(angle), math.cos(angle)]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for point in points:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        point_vector = np.transpose(np.matrix([point[0] - Flags.DIM / 2, point[1] - Flags.DIM / 2]))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        rotated = np.matmul(rotation_matrix, point_vector)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        rotated_vertices = (math.floor(rotated.item((0, 0))) + Flags.DIM / 2, math.floor(rotated.item((1, 0))) + Flags.DIM / 2)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        result.append(rotated_vertices)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return result123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef cut(im):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return smarterCut(im)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef simpleCircleDefinedLineCut(im, r=0.3*Flags.DIM):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # TODO: Make it work for both positive and negative signs123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # FIXME (this function does not work)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Pick points a and b on the circle, but not too close to the boundary123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    a = randint(Flags.DIM / 2 - r, Flags.DIM / 2 + r)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    b = Flags.DIM / 2 + math.sqrt(r ** 2 - (a - Flags.DIM / 2) ** 2)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # slope (based on derivative)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    m = 0 - ((a - Flags.DIM / 2) / (math.sqrt(r ** 2 - (a - Flags.DIM / 2) ** 2)))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # y-intercept value123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    yInt = -a * m + b123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # x100-intercent value123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    x100Int = (0 - (Flags.DIM / 2) * (math.sqrt(0 - a ** 2 + Flags.DIM * a + r ** 2 - (Flags.DIM / 2)**2) + Flags.DIM / 2) + Flags.DIM / 2 * a + r ** 2) / (a - Flags.DIM / 2)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if (x100Int > Flags.DIM):  # Bound the x100-intercept at 100123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        x100Int = Flags.DIM123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print x100Int123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print yInt123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    print "___"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    vertices = [(0, 0), (0, x100Int), (Flags.DIM - yInt, 0)]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw = ImageDraw.Draw(im)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw.polygon(vertices, fill=128, outline=128)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    del draw123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return im123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef simpleLineCut(im):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''Trivial line generation--simply chooses two boundary points, one on top, one on bottom.'''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    top = randint(1, Flags.DIM)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    bottom = randint(1, Flags.DIM)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    vertices = [(0, 0), (randint(1, top), 0), (randint(1, bottom), Flags.DIM), (0, Flags.DIM)]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw = ImageDraw.Draw(im)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw.polygon(vertices, fill=0, outline=0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    del draw123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return im123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef smarterCut(im):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    (x, y) = (0, 0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    good = False123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # Pick a random pair of pixles within the shape123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    while good == False:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        x = randint(0, Flags.DIM - 1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        y = randint(0, Flags.DIM - 1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        (r, g, b) = im.getpixel((x, y))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if r != 0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            good = True123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    qs = randint(0, 1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    q = 0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if qs == 1:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        q = 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        q = -1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    m = randint(1, 1000) * 0.001123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    y_intercept = math.floor(0 - x * q * math.log(m) + y)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if y_intercept < 0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        y_intercept = 0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    elif y_intercept > Flags.DIM:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        y_intercept = Flags.DIM123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    qr = randint(0, 1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    vertices = []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if qr == 0:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        vertices = [(0, 0), (Flags.DIM, 0), (Flags.DIM, randint(0, y_intercept)), (0, y_intercept)]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        vertices = [(0, Flags.DIM), (0, y_intercept), (Flags.DIM, randint(0, Flags.DIM - y_intercept)), (Flags.DIM, Flags.DIM)]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw = ImageDraw.Draw(im)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    draw.polygon(vertices, fill=0, outline=0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    del draw123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return im123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef stable(im):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''Stability checks on the generated images (especially needed for naive cutting algorithms)'''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    valid = True123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    num_colored = 0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for i in range(0, Flags.DIM - 1):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        for j in range(0, Flags.DIM - 1):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            (r, g, b) = im.getpixel((i, j))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            if (r == 128):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                num_colored = num_colored + 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    percentColored = num_colored * 100 / Flags.DIM ** 2123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    if (percentColored < 5):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        valid = False123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return valid123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF