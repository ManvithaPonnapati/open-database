import tensorflow as tf123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport numpy as np123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFfrom glob import glob123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport os,time123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport av4_utils123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport av4_input123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef convert_protein_and_ligand_to_image(ligand_elements,ligand_coords,receptor_elements,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                        receptor_coords,side_pixels,pixel_size):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Take coordinates and elements of protein and ligand and convert them into an image.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Return image with one dimension so far."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # FIXME abandon ligand when it does not fit into the box (it's kept now)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # max_num_attempts - maximum number of affine transforms for the ligand to be tried123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    max_num_attemts = 1000123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # affine_transform_pool_size is the first(batch) dimension of tensor of transition matrices to be returned123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # affine tranform pool is only generated once in the beginning of training and randomly sampled afterwards123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    affine_transform_pool_size = 10000123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # transform center ligand around zero123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_center_of_mass = tf.reduce_mean(ligand_coords, reduction_indices=0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    centered_ligand_coords = ligand_coords - ligand_center_of_mass123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    centered_receptor_coords = receptor_coords - ligand_center_of_mass123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # use TF while loop to find such an affine transform matrix that can fit the ligand so that no atoms are outside123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    box_size = (tf.cast(side_pixels, tf.float32) * pixel_size)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def generate_transition_matrix(attempt,transition_matrix,batch_of_transition_matrices):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """Takes initial coordinates of the ligand, generates a random affine transform matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        and transforms coordinates.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        transition_matrix= tf.gather(batch_of_transition_matrices,tf.random_uniform([],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                                    minval=0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                                    maxval=affine_transform_pool_size,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                                    dtype=tf.int32))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        attempt += 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return attempt, transition_matrix,batch_of_transition_matrices123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def not_all_in_the_box(attempt, transition_matrix,batch_of_transition_matrices,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                           ligand_coords=centered_ligand_coords,box_size=box_size,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                           max_num_attempts=max_num_attemts):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """Takes affine transform matrix and box dimensions, performs the transformation, and checks if all atoms123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        are in the box."""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        transformed_coords, transition_matrix = av4_utils.affine_transform(ligand_coords, transition_matrix)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        not_all = tf.cast(tf.reduce_max(tf.cast(tf.square(box_size*0.5) - tf.square(transformed_coords) < 0,tf.int32)),123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                          tf.bool)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        within_iteration_limit = tf.cast(tf.reduce_sum(tf.cast(attempt < max_num_attemts, tf.float32)), tf.bool)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return tf.logical_and(within_iteration_limit, not_all)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    attempt = tf.Variable(tf.constant(0, shape=[1]))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    batch_of_transition_matrices = tf.Variable(av4_utils.generate_deep_affine_transform(affine_transform_pool_size))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    transition_matrix = tf.gather(batch_of_transition_matrices, tf.random_uniform([], minval=0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                                  maxval=affine_transform_pool_size-1,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                                  dtype=tf.int64))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    last_attempt,final_transition_matrix,_ = tf.while_loop(not_all_in_the_box, generate_transition_matrix,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                           [attempt, transition_matrix,batch_of_transition_matrices],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                           parallel_iterations=1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # rotate receptor and ligand using an affine transform matrix found123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rotatated_ligand_coords,_ = av4_utils.affine_transform(centered_ligand_coords,final_transition_matrix)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rotated_receptor_coords,_ = av4_utils.affine_transform(centered_receptor_coords,final_transition_matrix)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # check if all of the atoms are in the box, if not set the ligand to 0, but do not raise an error123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def set_elements_coords_zero(): return tf.constant([0],dtype=tf.int32),tf.constant([[0,0,0]],dtype=tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def keep_elements_coords(): return ligand_elements, rotatated_ligand_coords123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    not_all = tf.cast(tf.reduce_max(tf.cast(tf.square(box_size * 0.5) - tf.square(rotatated_ligand_coords) < 0,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                            tf.int32)),tf.bool)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_elements,rotatated_ligand_coords = tf.case({tf.equal(not_all,tf.constant(True)): set_elements_coords_zero},123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                      keep_elements_coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # move receptor randomly123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    label_transition_matrices, xyz_labels = av4_utils.gen_deep_affine_tform_with_labels(affine_transform_pool_size,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF									                                          x_rot_range=tf.convert_to_tensor(np.pi),123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                              #y_rot_range=tf.convert_to_tensor(np.pi))#,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                              #z_rot_range=tf.convert_to_tensor(np.pi),#,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                              #shift_partitions=1,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                              #rot_partitions = 1,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                              abs=True)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # rec_transition_matrices = tf.Variable(affine_initializer)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    random_slice = tf.random_uniform([], minval=0, maxval=affine_transform_pool_size, dtype=tf.int64)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    label_transition_matrix = tf.gather(label_transition_matrices,random_slice)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    xyz_label = tf.gather(xyz_labels, random_slice)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    twice_rotated_receptor_coords,_ = av4_utils.affine_transform(rotated_receptor_coords,label_transition_matrix)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # move coordinates of a complex to an integer number so as to put every atom on a grid123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # ceiled coords is an integer number out of real coordinates that corresponds to the index on the cell123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # epsilon - potentially, there might be very small rounding errors leading to additional indexes123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    epsilon = tf.constant(0.999, dtype=tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ceiled_ligand_coords = tf.cast(tf.round((-0.5 + (tf.cast(side_pixels,tf.float32)*0.5) +123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                             (rotatated_ligand_coords/pixel_size))*epsilon),tf.int64)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ceiled_receptor_coords = tf.cast(tf.round((-0.5 + (tf.cast(side_pixels, tf.float32) * 0.5) +123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                               (twice_rotated_receptor_coords/pixel_size))*epsilon),tf.int64)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # crop atoms of the protein that do not fit inside the box123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    top_filter = tf.reduce_max(ceiled_receptor_coords,reduction_indices=1)<side_pixels123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    bottom_filter = tf.reduce_min(ceiled_receptor_coords,reduction_indices=1)>0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    retain_atoms = tf.logical_and(top_filter,bottom_filter)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    cropped_receptor_coords = tf.boolean_mask(ceiled_receptor_coords,retain_atoms)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    cropped_receptor_elements = tf.boolean_mask(receptor_elements,retain_atoms)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # merge protein and ligand together. In this case an arbitrary value of 10 is added to the ligand123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    lig_coords_d = tf.concat([ceiled_ligand_coords,tf.expand_dims(tf.zeros([tf.shape(ceiled_ligand_coords)[0]],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                          dtype=tf.int64),1)],1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rec_coords_d = tf.concat([cropped_receptor_coords,tf.expand_dims(tf.ones([tf.shape(cropped_receptor_coords)[0]],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                             dtype=tf.int64),1)],1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    complex_coords_d = tf.concat([lig_coords_d,rec_coords_d],0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    complex_elements = tf.cast(tf.concat([ligand_elements, cropped_receptor_elements],0),tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # in coordinates of a protein rounded to the nearest integer can be represented as indices of a sparse 3D tensor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # values from the atom dictionary can be represented as values of a sparse tensor123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # in this case TF's sparse_tensor_to_dense can be used to generate an image out of rounded coordinates123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # move elemets to the dimension of depth123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    #complex_coords_4d = tf.concat([complex_coords, tf.reshape(tf.cast(complex_elements - 1, dtype=tf.int64), [-1, 1])],1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    sparse_image = tf.SparseTensor(indices=complex_coords_d, values=complex_elements,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                   dense_shape=[side_pixels,side_pixels,side_pixels,2])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    dense_image = tf.sparse_tensor_to_dense(sparse_image, validate_indices=False)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # FIXME: try to save an image and see how it looks like123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return dense_image,ligand_center_of_mass,final_transition_matrix,xyz_label123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef image_and_label_queue(batch_size,pixel_size,side_pixels,num_threads,filename_queue,epoch_counter,train=True):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """Creates shuffle queue for training the network"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # read one receptor and stack of ligands; choose one of the ligands from the stack according to epoch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ligand_file,current_epoch,label,ligand_elements,ligand_coords,receptor_elements,receptor_coords = \123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        av4_input.read_receptor_and_ligand(filename_queue,epoch_counter=epoch_counter,lig_frame_sampling='ZERO')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # convert coordinates of ligand and protein into an image123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    dense_image,_,_,xyz_label = convert_protein_and_ligand_to_image(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        ligand_elements,ligand_coords,receptor_elements,receptor_coords,side_pixels,pixel_size)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # create a batch of proteins and ligands to read them together123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    multithread_batch = tf.train.batch([ligand_file, current_epoch, label,xyz_label, dense_image],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                       batch_size,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                       num_threads=num_threads,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                       capacity=batch_size * 3,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                       dynamic_pad=True,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                       shapes=[[],[], [], [6], [side_pixels,side_pixels,side_pixels,2]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return multithread_batch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF