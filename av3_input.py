import random,time,threading123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport numpy as np123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport tensorflow as tf123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef generate_random_transition_matrix(shift_range=10,rotation_range=np.pi*2):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """returns a random transition matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rotation range - determines random rotations along any of X,Y,Z axis123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    shift_range determines allowed shifts along any of X,Y,Z axis """123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # REMARK: shift range is hard coded to 10A because that's how the proteins look like123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # randomly shift along X,Y,Z123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    xyz_shift_matrix = np.matrix([[1 ,0 , 0, random.random()*shift_range],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                 [0, 1, 0, random.random()*shift_range],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                 [0, 0, 1, random.random()*shift_range],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                 [0, 0, 0, 1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ## randomly rotate along X123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rand_x = random.random()*rotation_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    x_rotate_matrix = np.matrix([[1, 0, 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                               [0, np.cos(rand_x), - np.sin(rand_x), 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                               [0, np.sin(rand_x), np.cos(rand_x), 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                [0, 0, 0, 1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ## randomly rotate along Y123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rand_y = random.random()*rotation_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    y_rotate_matrix = np.matrix([[np.cos(rand_y), 0, np.sin(rand_y), 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                [0, 1, 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                [-np.sin(rand_y), 0, np.cos(rand_y), 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                [0, 0 ,0 ,1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ## randomly rotate along Z123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rand_z = random.random()*rotation_range123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    z_rotate_matrix = np.matrix([[np.cos(rand_z), -np.sin(rand_z), 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                               [np.sin(rand_z), np.cos(rand_z), 0, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                               [0, 0, 1, 0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                [0, 0, 0, 1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # combining all matrices into one by multiplication123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # nice property of the matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    xyz_rotate_shift_matrix =  xyz_shift_matrix * x_rotate_matrix * y_rotate_matrix * z_rotate_matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return xyz_rotate_shift_matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef affine_transform(coordinate_array,transition_matrix):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """applies transition to every point of the array"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    matrix_coord = np.matrix(coordinate_array)    # np.matrix has different defaults compared to np.array123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    raw_of_ones = np.matrix(np.ones(len(matrix_coord[:,0])))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    transformed_coord = (transition_matrix * np.vstack((matrix_coord.transpose(),raw_of_ones)))[0:3,:].transpose()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return np.array(transformed_coord)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#def affine_transform_old(coordinate_array,transition_matrix):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    """applies transition to every point in array"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    def transform_one_point(one_point,transition_matrix=transition_matrix):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#        return np.sum(transition_matrix * np.matrix(np.append(one_point,1)).transpose(),axis=1)[0:3]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    transformed_coordinates = np.array(map(transform_one_point,coordinate_array[:,0:3])).reshape(-1,3)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF#    return transformed_coordinate123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef launch_enqueue_workers(sess,pixel_size,side_pixels,num_workers,batch_size,database_index_file_path,num_epochs):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    """1) loads a whole database file into RAM.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF       2) creates coordinator and picks protein-ligand-label trios in random order123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF       3) creates many workers that collectively pick data from coordinator123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF       4) each worker randomly rotates and shifts the box around the ligand center (data augmentation)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF       5) each worker converts coordinates(sparse tensor) to image(dense tensor) and enqueues it"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    class molecule_class():123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """simple class to store the information about the molecule"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        coords = np.array([[]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        atom_tags = np.array([[]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        def load_npy(self, file_path):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            raw_array = np.load(file_path)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            self.coords = raw_array[:, 0:3]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            self.atom_tags = raw_array[:, 3]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    class filename_coordinator_class():123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """helps many background processes to read and enqueue images123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        1) holds database index123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        2) holds information about which images have been read"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                                    # TODO add randomization of readings123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                                                                    # TODO make it read an ~exact amount of entries123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        labels = []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        ligand_filenames = []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        receptor_filenames = []123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # counter counts the index of the record of numpy array to return123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        counter = 0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        index_file_size = 0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # "stop" to stop the threads123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        stop = False123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # number of epochs to train for123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        num_epochs = 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # current epoch number123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        epoch = 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # because multiple threads are reading from coordinator at the same time123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # it is possible that thread 2 will increment while thread 1 got value1[i],value2[i],but not value3[i]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # thread 1 would read value1[i],value2[i],value3[i+1]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        lock = threading.Lock()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        def load_database_index_file(self, database_index_file_path):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            raw_database_array = np.genfromtxt(database_index_file_path, delimiter=',', dtype=str)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            self.labels = np.asarray(raw_database_array[:, 0], dtype=np.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            self.ligand_filenames = raw_database_array[:, 1]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            self.receptor_filenames = raw_database_array[:, 2]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            self.index_file_size = len(self.labels)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            print "database index file has been loaded"123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        def iterate_one(self,lock=lock):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            with lock:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                label = self.labels[self.counter]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                ligand_filename = self.ligand_filenames[self.counter]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                receptor_filename = self.receptor_filenames[self.counter]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                if (self.index_file_size - 1) > self.counter:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                    self.counter += 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                    # when end of file list if reached see if it's the last epoch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                    if num_epochs > self.epoch:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                        self.epoch +=1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                        self.counter=0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                        print "training epoch:",self.epoch123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                    else:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                        # stop the workers123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                        # gracefully stop123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                        self.stop = True123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                        self.counter=0123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            return label, ligand_filename, receptor_filename123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def if_in_the_box(atom_coord_array, box_edge=pixel_size * side_pixels):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """returns a boolean array of size equal to height of atom_coord_array123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        True - when in the box, False - when outside of the box"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        pos_filter = -np.asarray(np.asarray((np.amax(atom_coord_array, axis=1)) / (0.5 * box_edge), dtype=int),123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                dtype=bool)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        neg_filter = -np.asarray(np.asarray((- np.amin(atom_coord_array, axis=1)) / (0.5 * box_edge), dtype=int),123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                dtype=bool)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        filter = pos_filter * neg_filter123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        return filter123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # a small tensorgraph for image conversion123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # it's important that it stays outside of any loops and is only called once123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    ceiled_coords = tf.placeholder(tf.int64, [None, 3])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    atom_tags = tf.placeholder(tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    final_filter = tf.placeholder(tf.bool)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    sparse_prot = tf.SparseTensor(indices=ceiled_coords, values=atom_tags,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                  shape=[side_pixels, side_pixels, side_pixels])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    filtered_prot = tf.sparse_retain(sparse_prot, final_filter)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    feed_image = tf.sparse_tensor_to_dense(filtered_prot, validate_indices=False)                    # TODO when two atoms go into one cell123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # label should be fed separately123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    feed_label = tf.placeholder(tf.float32)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # ligand and filename are fed for universality to be used in evaluations123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    feed_ligand_filename = tf.placeholder(tf.string)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    feed_receptor_filename = tf.placeholder(tf.string)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # a simple custom queue that will be used to store images123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    image_queue = tf.FIFOQueue(100 + num_workers * batch_size, [tf.float32,tf.float32,tf.string,tf.string], shapes=[[],[side_pixels,side_pixels,side_pixels],[],[]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    enqueue_image_op = image_queue.enqueue([feed_label,feed_image,feed_ligand_filename,feed_receptor_filename])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def image_queue_worker(filename_coordinator,pixel_size=pixel_size, side_pixels=side_pixels,num_attempts=1000):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        """1) makes random affine transform matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF           2) applies affine transform to the ligand123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF           3) checks if all atoms are in the box, if not, repeats (1)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF           4) sends an image to the queue"""123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        while True:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            label, ligand_filename, receptor_filename = filename_coordinator.iterate_one()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # loading ligand molecule123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            ligand_molecule = molecule_class()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            ligand_molecule.load_npy(ligand_filename)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # shifting to the new center of mass123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            ligand_center_of_mass = np.average(ligand_molecule.coords,axis=0)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            ligand_molecule.coords = ligand_molecule.coords - ligand_center_of_mass123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # find transition matrix that could fit all the ligand atoms123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            final_transition_matrix = False123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            for attempt in range(num_attempts):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                # make a random transition matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                random_transition_matrix = generate_random_transition_matrix()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                # affine transform123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                transformed_ligand_coord = affine_transform(ligand_molecule.coords, random_transition_matrix)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                # see if all ligand atoms are in the box123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                if all(if_in_the_box(transformed_ligand_coord)):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                    final_transition_matrix = random_transition_matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                    break123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # check if attempt to generate the transition matrix was successful123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # if not, exit procedure123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            if isinstance(final_transition_matrix, bool):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                print "reached maximum number of attempts and failed", num_attempts                                     #TODO write this into log123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                # "pass" rewinds loop to the beginning without enqueing image123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                pass123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # if the script goes past this point it means that transition matrix was successfully generated123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # transform ligand to the new coordinate system (only do it once)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            ligand_molecule.coords = affine_transform(ligand_molecule.coords,final_transition_matrix)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # parse the protein (receptor)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            receptor_molecule = molecule_class()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            receptor_molecule.load_npy(receptor_filename)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # transform the protein in the same way as the ligand123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            receptor_molecule.coords = receptor_molecule.coords - ligand_center_of_mass123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            receptor_molecule.coords = affine_transform(receptor_molecule.coords,final_transition_matrix)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # now merge the molecule coordinates and atom names123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            molecule_complex = molecule_class()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            molecule_complex.coords = np.vstack((ligand_molecule.coords,receptor_molecule.coords))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            molecule_complex.atom_tags = np.hstack((ligand_molecule.atom_tags,receptor_molecule.atom_tags))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # moving coordinates of a complex to an integer number so as to put every atom on a grid123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            # ceiled coords is an integer number out of real coordinates that corresponds to the index on the cell123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            molecule_complex.ceiled_coords = np.asarray(np.round(molecule_complex.coords / pixel_size - 0.5 + side_pixels / 2), dtype=int)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            molecule_complex.filter = if_in_the_box(atom_coord_array=molecule_complex.coords)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            sess.run([enqueue_image_op], feed_dict={feed_label:label, ceiled_coords: molecule_complex.ceiled_coords, atom_tags: molecule_complex.atom_tags,123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF                                     final_filter: molecule_complex.filter,feed_ligand_filename:ligand_filename,feed_receptor_filename:receptor_filename})123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # load the database index file123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    filename_coordinator = filename_coordinator_class()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    filename_coordinator.load_database_index_file(database_index_file_path)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    filename_coordinator.num_epochs = num_epochs123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # launch many enqueue workers to fill the queue at the same time123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    image_enqueue_threads = [threading.Thread(target=image_queue_worker,args=(filename_coordinator,)) for worker_name in xrange(num_workers)]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    for t in image_enqueue_threads:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        print "thread started:",t123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        t.start()123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # sleep 0.3 seconds every time before launching next thread to avoid the situation123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        # when too many threads are requesting memory access at the same time123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        time.sleep(0.3)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return image_queue,filename_coordinator