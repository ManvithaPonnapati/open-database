import prody as protein123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFimport numpy as np123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF'''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFBackground: It will be much easier to use 4*4 matrix instead of 3*3 matrix to do transformation.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFThis will help when the program needs to judge whether the ligand is in rotated boxes, (in case of loss of information)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFTo be simple , all matrix is right-associative i.e.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF[x',y',z',1] = [x,y,z,1]*T123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFT is transformation matrix123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF'''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef rotation_matrix_by_x(theta):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    just return the rotation matrix with clockwise theta degree along x-axis123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param coord:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param theta:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return np.matrix(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [[1,0,0,0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [0,np.cos(theta),-np.sin(theta),0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [0,np.sin(theta),np.cos(theta),0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [0,0,0,1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef rotation_matrix_by_y(theta):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    just return the rotation matrix with clockwise theta degree along y-axis123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param coord:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param theta:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return np.matrix(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [[np.cos(theta),0,np.sin(theta),0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [0,1,0,0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [-np.sin(theta),0,np.cos(theta),0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [0,0,0,1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef rotation_matrix_by_z(theta):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    just return the rotation matrix with clockwise theta degree along z-axis123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param coord:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param theta:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return np.matrix(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [[np.cos(theta),-np.sin(theta),0,0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [np.sin(theta),np.cos(theta),0,0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [0,0,1,0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [0,0,0,1]])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef transition_matrix(coord):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param coord:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param shift:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return np.matrix(123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        [[1,0,0,0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [0,1,0,0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [0,0,1,0],123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         [coord[0],coord[1],coord[2],1]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF         ]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    )123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef get_rotation_marix_along_anyaxis(center,rotation):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    There is a vector as rotation axis, which starts at center and123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    according to following steps to be that direction:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    0. It originally point along +z-axis123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    1. It rotate clockwisely with rotation[0] degree along x-axis123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    2. It rotate clockwisely with rotation[1] degree along y-axis123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    3. It rotate clockwisely with rotation[2] degree along z-axis123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    (P.S. 6-freedom)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param center: center vector (used in transition transformation)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param rotation: rotation vector (used in rotation transformation)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    T = transition_matrix(-center)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    T_inv= transition_matrix(center)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    R_x = rotation_matrix_by_x(rotation[0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    R_x_inv = rotation_matrix_by_x(-rotation[0])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    R_y = rotation_matrix_by_y(rotation[1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    R_y_inv = rotation_matrix_by_y(-rotation[1])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    R_z = rotation_matrix_by_z(rotation[2])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return reduce(np.dot, [T,R_x,R_y,R_z,R_y_inv,R_x_inv,T_inv])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef get_transformation_inv_fromoldtonew(new_xcoord,new_ycoord,new_zcoord,transition):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param new_xcoord: (1,0,0) -> (ux,uy,uz)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param new_ycoord: (0,1,0) -> (vx,vy,vz)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param new_zcoord: (0,0,1) -> (wx,wy,wz)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param transition: **very important** this is used to align the start (may be down-left coordinate after rotation)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    because we need vectors instead of absolute coordinate to calculate123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    i.e. (a*ux+transition[0],a*uy+transition[1],a*uz+transition[2]) might represent one edge of a cubic box.123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return: **Inverse matrix** of this transformation123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    T_inv = transition_matrix(-transition)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    U= np.matrix([new_xcoord,new_ycoord,new_zcoord])123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return np.dot(T_inv*U.transpose())123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef get_coord_after_transformation(coord,transformation_matrix):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    return np.dot(coord+[1],transformation_matrix)[0:2]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFdef in_cubic_box(coords, Box, BOXsize= 20):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    This is the function that used to judge whether the coords are in the cubix box or not123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param coords:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param center:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :param BOXsize:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    :return:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    pass123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFclass Box:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    center= [0,0,0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Boxsize= 20123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    down_left = [0,0,0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    # resolution of box123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Boxrange= 1123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    Boxnum =  int(np.ceil(Boxsize+0.01 / Boxrange))123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    rotation = [0,0,0]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def __init__(self,**kwargs):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if 'center' in kwargs:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            self.center= kwargs['center']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if 'center' in kwargs:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            self.center = kwargs['center']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if 'center' in kwargs:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            self.center = kwargs['center']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if 'center' in kwargs:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            self.center = kwargs['center']123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNFclass vector_generator:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    receptor= None123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF    def __init__(self,receptor_filename):123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        :param receptor_filename: source pdb file or .gz file that can be opened and parsed123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        '''123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        try:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            parse = protein.parsePDB(receptor_filename)123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        except:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            print 'Cannot parse file %s, please check your input' % receptor_filename.split('/')[-1]123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            return False123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        self.receptor= parse.select('protein')123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF        if parse.select('nucleic') is not None:123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            print 'This program does not support nucleic cocrystal structure for now.'123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF            return False123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF123343DJNBFHJBJNKFJNBHDRFBNJKDJUNF